
// --- lexer ---
let tabWidth: Int = 4
var indent: Int = 0

SEMICOLON = [;]

INTEGER = [0-9]+
FLOAT = [0-9]+ [.] [0-9]+
STRING = ["] .*? ["]
IDENTIFIER = [a-zA-z_][0-9a-zA-z_]*

WHITESPACE = [ \t] -> Nil

PLUS = [+]
MINUS = [-]

indentation
	INDENT
	DEDENT
	NEWLINE = [\n] ->
		var newIndent: Int = 0
		while match
			[ ] -> newIndent += 1
			[\t] -> newIndent = (newIndent / tabWidth + 1) * tabWidth
			[\n] -> newIndent = 0
		let oldIndent: Int = indent
		indent = newIndent

		check(newIndent % tabWidth == 0, "Indentation must be a power of 4.")

		emit NEWLINE
		newIndent > oldIndent ->
			emit INDENT
		while newIndent < oldIndent ->
			newIndent += tabWidth
			emit DEDENT

// --- parser ---
binaryExpr =
	expr (PLUS or MINUS) expr

expr =
	INTEGER
	FLOAT
	STRING
	IDENTIFIER
	binaryExpr

stmt = expr SEMICOLON

// --- typer ---
builtin(Int, Float, String)
Int < Float

INTEGER _ = Int
FLOAT _ = Float
STRING _ = String

IDENTIFIER(ident, env) = env.get(ident)

binaryExpr =
	l:expr (PLUS or MINUS) r:expr =
		// either one is convertible to the other or both are equal
		assert l <> r
		l

// expr is implicitly the type of its union variant

stmt _ = Nil

// --- generator ---
Int -> Yune'Int
Float -> Yune'Float
String -> Yune'String

binaryExpr
	l:expr PLUS r:expr -> yune#l + r
	l:expr MINUS r:expr -> yune#l - r

e:expr -> yune#e
