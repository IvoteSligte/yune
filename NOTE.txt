
compilation order of a function
	1. type check the header (depends on types used in header)
	2. type check the body (depends on types and types of globals used in body)
 
compilation order of a constant
	1. type check the type annotation (depends on types used in type annotation)
	2. type check the body (depends on types and types of globals used in body)
	3. if required at compile-time, calculate value of constant

dependency kinds
	type->value
		declaration // the type of a declaration depends on the values of its type annotations

	value->type  // everything at the type checking step

	value->value // a global constant value is used in the body of a declaration
		expression // variable use or function call that rely on global declarations

--- January 14 ---

co-recursion

checked code injection
	JS/python in HTML; unlike C macro library that is unhygienic
	templating, but checked at compile-time
	formatting vulnerability
	C printf vulnerability

embedding game assets at compile-time

macros that generate Yune AST, possibly including more macros

helper for easily parsing macros according to Tobias' suggestions
       e.g. 

parser(s: String): (type_dependencies, Fn(resolved_type_dependencies) -> (value_dependencies, Fn(resolved...) -> output) =
	  info = preprocessor(s, "::")
	  ...


FIXME: comments don't work

// Macro signature: (text: String) -> (error: String, output: Expression)
//
// Returns the given text as a string literal.
// Facilitates creation of multiline strings.



	// Returns the dependencies required for evaluation.
	// Macros are required to be evaluated before everything else, as they generate code.
	// The queries are things that need to be evaluated before type checking, such as types.
	// Then lastly the variables describe global variables and functions used at evaluation time.
	Dependencies() (macros []*Macro, queries []Query, variables []Name)

