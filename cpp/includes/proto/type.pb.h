// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/type.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2ftype_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proto_2ftype_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2ftype_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2ftype_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proto_2ftype_2eproto;
namespace yune {
class Type;
struct TypeDefaultTypeInternal;
extern TypeDefaultTypeInternal _Type_default_instance_;
class Type_Bool;
struct Type_BoolDefaultTypeInternal;
extern Type_BoolDefaultTypeInternal _Type_Bool_default_instance_;
class Type_Float;
struct Type_FloatDefaultTypeInternal;
extern Type_FloatDefaultTypeInternal _Type_Float_default_instance_;
class Type_Fn;
struct Type_FnDefaultTypeInternal;
extern Type_FnDefaultTypeInternal _Type_Fn_default_instance_;
class Type_Int;
struct Type_IntDefaultTypeInternal;
extern Type_IntDefaultTypeInternal _Type_Int_default_instance_;
class Type_List;
struct Type_ListDefaultTypeInternal;
extern Type_ListDefaultTypeInternal _Type_List_default_instance_;
class Type_String;
struct Type_StringDefaultTypeInternal;
extern Type_StringDefaultTypeInternal _Type_String_default_instance_;
class Type_Tuple;
struct Type_TupleDefaultTypeInternal;
extern Type_TupleDefaultTypeInternal _Type_Tuple_default_instance_;
}  // namespace yune
PROTOBUF_NAMESPACE_OPEN
template<> ::yune::Type* Arena::CreateMaybeMessage<::yune::Type>(Arena*);
template<> ::yune::Type_Bool* Arena::CreateMaybeMessage<::yune::Type_Bool>(Arena*);
template<> ::yune::Type_Float* Arena::CreateMaybeMessage<::yune::Type_Float>(Arena*);
template<> ::yune::Type_Fn* Arena::CreateMaybeMessage<::yune::Type_Fn>(Arena*);
template<> ::yune::Type_Int* Arena::CreateMaybeMessage<::yune::Type_Int>(Arena*);
template<> ::yune::Type_List* Arena::CreateMaybeMessage<::yune::Type_List>(Arena*);
template<> ::yune::Type_String* Arena::CreateMaybeMessage<::yune::Type_String>(Arena*);
template<> ::yune::Type_Tuple* Arena::CreateMaybeMessage<::yune::Type_Tuple>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace yune {

// ===================================================================

class Type_Int final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:yune.Type.Int) */ {
 public:
  inline Type_Int() : Type_Int(nullptr) {}
  explicit constexpr Type_Int(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_Int(const Type_Int& from);
  Type_Int(Type_Int&& from) noexcept
    : Type_Int() {
    *this = ::std::move(from);
  }

  inline Type_Int& operator=(const Type_Int& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_Int& operator=(Type_Int&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_Int& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_Int* internal_default_instance() {
    return reinterpret_cast<const Type_Int*>(
               &_Type_Int_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Type_Int& a, Type_Int& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_Int* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_Int* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_Int* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_Int>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Type_Int& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Type_Int& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "yune.Type.Int";
  }
  protected:
  explicit Type_Int(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:yune.Type.Int)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_Float final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:yune.Type.Float) */ {
 public:
  inline Type_Float() : Type_Float(nullptr) {}
  explicit constexpr Type_Float(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_Float(const Type_Float& from);
  Type_Float(Type_Float&& from) noexcept
    : Type_Float() {
    *this = ::std::move(from);
  }

  inline Type_Float& operator=(const Type_Float& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_Float& operator=(Type_Float&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_Float& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_Float* internal_default_instance() {
    return reinterpret_cast<const Type_Float*>(
               &_Type_Float_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Type_Float& a, Type_Float& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_Float* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_Float* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_Float* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_Float>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Type_Float& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Type_Float& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "yune.Type.Float";
  }
  protected:
  explicit Type_Float(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:yune.Type.Float)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_Bool final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:yune.Type.Bool) */ {
 public:
  inline Type_Bool() : Type_Bool(nullptr) {}
  explicit constexpr Type_Bool(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_Bool(const Type_Bool& from);
  Type_Bool(Type_Bool&& from) noexcept
    : Type_Bool() {
    *this = ::std::move(from);
  }

  inline Type_Bool& operator=(const Type_Bool& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_Bool& operator=(Type_Bool&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_Bool& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_Bool* internal_default_instance() {
    return reinterpret_cast<const Type_Bool*>(
               &_Type_Bool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Type_Bool& a, Type_Bool& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_Bool* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_Bool* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_Bool* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_Bool>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Type_Bool& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Type_Bool& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "yune.Type.Bool";
  }
  protected:
  explicit Type_Bool(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:yune.Type.Bool)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_String final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:yune.Type.String) */ {
 public:
  inline Type_String() : Type_String(nullptr) {}
  explicit constexpr Type_String(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_String(const Type_String& from);
  Type_String(Type_String&& from) noexcept
    : Type_String() {
    *this = ::std::move(from);
  }

  inline Type_String& operator=(const Type_String& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_String& operator=(Type_String&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_String& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_String* internal_default_instance() {
    return reinterpret_cast<const Type_String*>(
               &_Type_String_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Type_String& a, Type_String& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_String* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_String* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_String* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_String>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Type_String& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Type_String& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "yune.Type.String";
  }
  protected:
  explicit Type_String(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:yune.Type.String)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_Fn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:yune.Type.Fn) */ {
 public:
  inline Type_Fn() : Type_Fn(nullptr) {}
  ~Type_Fn() override;
  explicit constexpr Type_Fn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_Fn(const Type_Fn& from);
  Type_Fn(Type_Fn&& from) noexcept
    : Type_Fn() {
    *this = ::std::move(from);
  }

  inline Type_Fn& operator=(const Type_Fn& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_Fn& operator=(Type_Fn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_Fn& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_Fn* internal_default_instance() {
    return reinterpret_cast<const Type_Fn*>(
               &_Type_Fn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Type_Fn& a, Type_Fn& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_Fn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_Fn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_Fn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_Fn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_Fn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_Fn& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_Fn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "yune.Type.Fn";
  }
  protected:
  explicit Type_Fn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgumentTypeFieldNumber = 1,
    kReturnTypeFieldNumber = 2,
  };
  // .yune.Type argumentType = 1;
  bool has_argumenttype() const;
  private:
  bool _internal_has_argumenttype() const;
  public:
  void clear_argumenttype();
  const ::yune::Type& argumenttype() const;
  PROTOBUF_NODISCARD ::yune::Type* release_argumenttype();
  ::yune::Type* mutable_argumenttype();
  void set_allocated_argumenttype(::yune::Type* argumenttype);
  private:
  const ::yune::Type& _internal_argumenttype() const;
  ::yune::Type* _internal_mutable_argumenttype();
  public:
  void unsafe_arena_set_allocated_argumenttype(
      ::yune::Type* argumenttype);
  ::yune::Type* unsafe_arena_release_argumenttype();

  // .yune.Type returnType = 2;
  bool has_returntype() const;
  private:
  bool _internal_has_returntype() const;
  public:
  void clear_returntype();
  const ::yune::Type& returntype() const;
  PROTOBUF_NODISCARD ::yune::Type* release_returntype();
  ::yune::Type* mutable_returntype();
  void set_allocated_returntype(::yune::Type* returntype);
  private:
  const ::yune::Type& _internal_returntype() const;
  ::yune::Type* _internal_mutable_returntype();
  public:
  void unsafe_arena_set_allocated_returntype(
      ::yune::Type* returntype);
  ::yune::Type* unsafe_arena_release_returntype();

  // @@protoc_insertion_point(class_scope:yune.Type.Fn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::yune::Type* argumenttype_;
  ::yune::Type* returntype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_Tuple final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:yune.Type.Tuple) */ {
 public:
  inline Type_Tuple() : Type_Tuple(nullptr) {}
  ~Type_Tuple() override;
  explicit constexpr Type_Tuple(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_Tuple(const Type_Tuple& from);
  Type_Tuple(Type_Tuple&& from) noexcept
    : Type_Tuple() {
    *this = ::std::move(from);
  }

  inline Type_Tuple& operator=(const Type_Tuple& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_Tuple& operator=(Type_Tuple&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_Tuple& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_Tuple* internal_default_instance() {
    return reinterpret_cast<const Type_Tuple*>(
               &_Type_Tuple_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Type_Tuple& a, Type_Tuple& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_Tuple* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_Tuple* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_Tuple* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_Tuple>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_Tuple& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_Tuple& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_Tuple* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "yune.Type.Tuple";
  }
  protected:
  explicit Type_Tuple(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElementsFieldNumber = 1,
  };
  // repeated .yune.Type elements = 1;
  int elements_size() const;
  private:
  int _internal_elements_size() const;
  public:
  void clear_elements();
  ::yune::Type* mutable_elements(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::yune::Type >*
      mutable_elements();
  private:
  const ::yune::Type& _internal_elements(int index) const;
  ::yune::Type* _internal_add_elements();
  public:
  const ::yune::Type& elements(int index) const;
  ::yune::Type* add_elements();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::yune::Type >&
      elements() const;

  // @@protoc_insertion_point(class_scope:yune.Type.Tuple)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::yune::Type > elements_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_List final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:yune.Type.List) */ {
 public:
  inline Type_List() : Type_List(nullptr) {}
  ~Type_List() override;
  explicit constexpr Type_List(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_List(const Type_List& from);
  Type_List(Type_List&& from) noexcept
    : Type_List() {
    *this = ::std::move(from);
  }

  inline Type_List& operator=(const Type_List& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_List& operator=(Type_List&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_List& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_List* internal_default_instance() {
    return reinterpret_cast<const Type_List*>(
               &_Type_List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Type_List& a, Type_List& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_List* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_List* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_List>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_List& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_List& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_List* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "yune.Type.List";
  }
  protected:
  explicit Type_List(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElementFieldNumber = 1,
  };
  // .yune.Type element = 1;
  bool has_element() const;
  private:
  bool _internal_has_element() const;
  public:
  void clear_element();
  const ::yune::Type& element() const;
  PROTOBUF_NODISCARD ::yune::Type* release_element();
  ::yune::Type* mutable_element();
  void set_allocated_element(::yune::Type* element);
  private:
  const ::yune::Type& _internal_element() const;
  ::yune::Type* _internal_mutable_element();
  public:
  void unsafe_arena_set_allocated_element(
      ::yune::Type* element);
  ::yune::Type* unsafe_arena_release_element();

  // @@protoc_insertion_point(class_scope:yune.Type.List)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::yune::Type* element_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:yune.Type) */ {
 public:
  inline Type() : Type(nullptr) {}
  ~Type() override;
  explicit constexpr Type(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type(const Type& from);
  Type(Type&& from) noexcept
    : Type() {
    *this = ::std::move(from);
  }

  inline Type& operator=(const Type& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type& operator=(Type&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type& default_instance() {
    return *internal_default_instance();
  }
  enum IsCase {
    kInt = 1,
    kFloat = 2,
    kBool = 3,
    kString = 4,
    kFn = 5,
    kTuple = 6,
    kList = 7,
    IS_NOT_SET = 0,
  };

  static inline const Type* internal_default_instance() {
    return reinterpret_cast<const Type*>(
               &_Type_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Type& a, Type& b) {
    a.Swap(&b);
  }
  inline void Swap(Type* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "yune.Type";
  }
  protected:
  explicit Type(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Type_Int Int;
  typedef Type_Float Float;
  typedef Type_Bool Bool;
  typedef Type_String String;
  typedef Type_Fn Fn;
  typedef Type_Tuple Tuple;
  typedef Type_List List;

  // accessors -------------------------------------------------------

  enum : int {
    kIntFieldNumber = 1,
    kFloatFieldNumber = 2,
    kBoolFieldNumber = 3,
    kStringFieldNumber = 4,
    kFnFieldNumber = 5,
    kTupleFieldNumber = 6,
    kListFieldNumber = 7,
  };
  // .yune.Type.Int int = 1;
  bool has_int_() const;
  private:
  bool _internal_has_int_() const;
  public:
  void clear_int_();
  const ::yune::Type_Int& int_() const;
  PROTOBUF_NODISCARD ::yune::Type_Int* release_int_();
  ::yune::Type_Int* mutable_int_();
  void set_allocated_int_(::yune::Type_Int* int_);
  private:
  const ::yune::Type_Int& _internal_int_() const;
  ::yune::Type_Int* _internal_mutable_int_();
  public:
  void unsafe_arena_set_allocated_int_(
      ::yune::Type_Int* int_);
  ::yune::Type_Int* unsafe_arena_release_int_();

  // .yune.Type.Float float = 2;
  bool has_float_() const;
  private:
  bool _internal_has_float_() const;
  public:
  void clear_float_();
  const ::yune::Type_Float& float_() const;
  PROTOBUF_NODISCARD ::yune::Type_Float* release_float_();
  ::yune::Type_Float* mutable_float_();
  void set_allocated_float_(::yune::Type_Float* float_);
  private:
  const ::yune::Type_Float& _internal_float_() const;
  ::yune::Type_Float* _internal_mutable_float_();
  public:
  void unsafe_arena_set_allocated_float_(
      ::yune::Type_Float* float_);
  ::yune::Type_Float* unsafe_arena_release_float_();

  // .yune.Type.Bool bool = 3;
  bool has_bool_() const;
  private:
  bool _internal_has_bool_() const;
  public:
  void clear_bool_();
  const ::yune::Type_Bool& bool_() const;
  PROTOBUF_NODISCARD ::yune::Type_Bool* release_bool_();
  ::yune::Type_Bool* mutable_bool_();
  void set_allocated_bool_(::yune::Type_Bool* bool_);
  private:
  const ::yune::Type_Bool& _internal_bool_() const;
  ::yune::Type_Bool* _internal_mutable_bool_();
  public:
  void unsafe_arena_set_allocated_bool_(
      ::yune::Type_Bool* bool_);
  ::yune::Type_Bool* unsafe_arena_release_bool_();

  // .yune.Type.String string = 4;
  bool has_string() const;
  private:
  bool _internal_has_string() const;
  public:
  void clear_string();
  const ::yune::Type_String& string() const;
  PROTOBUF_NODISCARD ::yune::Type_String* release_string();
  ::yune::Type_String* mutable_string();
  void set_allocated_string(::yune::Type_String* string);
  private:
  const ::yune::Type_String& _internal_string() const;
  ::yune::Type_String* _internal_mutable_string();
  public:
  void unsafe_arena_set_allocated_string(
      ::yune::Type_String* string);
  ::yune::Type_String* unsafe_arena_release_string();

  // .yune.Type.Fn fn = 5;
  bool has_fn() const;
  private:
  bool _internal_has_fn() const;
  public:
  void clear_fn();
  const ::yune::Type_Fn& fn() const;
  PROTOBUF_NODISCARD ::yune::Type_Fn* release_fn();
  ::yune::Type_Fn* mutable_fn();
  void set_allocated_fn(::yune::Type_Fn* fn);
  private:
  const ::yune::Type_Fn& _internal_fn() const;
  ::yune::Type_Fn* _internal_mutable_fn();
  public:
  void unsafe_arena_set_allocated_fn(
      ::yune::Type_Fn* fn);
  ::yune::Type_Fn* unsafe_arena_release_fn();

  // .yune.Type.Tuple tuple = 6;
  bool has_tuple() const;
  private:
  bool _internal_has_tuple() const;
  public:
  void clear_tuple();
  const ::yune::Type_Tuple& tuple() const;
  PROTOBUF_NODISCARD ::yune::Type_Tuple* release_tuple();
  ::yune::Type_Tuple* mutable_tuple();
  void set_allocated_tuple(::yune::Type_Tuple* tuple);
  private:
  const ::yune::Type_Tuple& _internal_tuple() const;
  ::yune::Type_Tuple* _internal_mutable_tuple();
  public:
  void unsafe_arena_set_allocated_tuple(
      ::yune::Type_Tuple* tuple);
  ::yune::Type_Tuple* unsafe_arena_release_tuple();

  // .yune.Type.List list = 7;
  bool has_list() const;
  private:
  bool _internal_has_list() const;
  public:
  void clear_list();
  const ::yune::Type_List& list() const;
  PROTOBUF_NODISCARD ::yune::Type_List* release_list();
  ::yune::Type_List* mutable_list();
  void set_allocated_list(::yune::Type_List* list);
  private:
  const ::yune::Type_List& _internal_list() const;
  ::yune::Type_List* _internal_mutable_list();
  public:
  void unsafe_arena_set_allocated_list(
      ::yune::Type_List* list);
  ::yune::Type_List* unsafe_arena_release_list();

  void clear_is();
  IsCase is_case() const;
  // @@protoc_insertion_point(class_scope:yune.Type)
 private:
  class _Internal;
  void set_has_int_();
  void set_has_float_();
  void set_has_bool_();
  void set_has_string();
  void set_has_fn();
  void set_has_tuple();
  void set_has_list();

  inline bool has_is() const;
  inline void clear_has_is();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union IsUnion {
    constexpr IsUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::yune::Type_Int* int__;
    ::yune::Type_Float* float__;
    ::yune::Type_Bool* bool__;
    ::yune::Type_String* string_;
    ::yune::Type_Fn* fn_;
    ::yune::Type_Tuple* tuple_;
    ::yune::Type_List* list_;
  } is_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_proto_2ftype_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Type_Int

// -------------------------------------------------------------------

// Type_Float

// -------------------------------------------------------------------

// Type_Bool

// -------------------------------------------------------------------

// Type_String

// -------------------------------------------------------------------

// Type_Fn

// .yune.Type argumentType = 1;
inline bool Type_Fn::_internal_has_argumenttype() const {
  return this != internal_default_instance() && argumenttype_ != nullptr;
}
inline bool Type_Fn::has_argumenttype() const {
  return _internal_has_argumenttype();
}
inline void Type_Fn::clear_argumenttype() {
  if (GetArenaForAllocation() == nullptr && argumenttype_ != nullptr) {
    delete argumenttype_;
  }
  argumenttype_ = nullptr;
}
inline const ::yune::Type& Type_Fn::_internal_argumenttype() const {
  const ::yune::Type* p = argumenttype_;
  return p != nullptr ? *p : reinterpret_cast<const ::yune::Type&>(
      ::yune::_Type_default_instance_);
}
inline const ::yune::Type& Type_Fn::argumenttype() const {
  // @@protoc_insertion_point(field_get:yune.Type.Fn.argumentType)
  return _internal_argumenttype();
}
inline void Type_Fn::unsafe_arena_set_allocated_argumenttype(
    ::yune::Type* argumenttype) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(argumenttype_);
  }
  argumenttype_ = argumenttype;
  if (argumenttype) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:yune.Type.Fn.argumentType)
}
inline ::yune::Type* Type_Fn::release_argumenttype() {
  
  ::yune::Type* temp = argumenttype_;
  argumenttype_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::yune::Type* Type_Fn::unsafe_arena_release_argumenttype() {
  // @@protoc_insertion_point(field_release:yune.Type.Fn.argumentType)
  
  ::yune::Type* temp = argumenttype_;
  argumenttype_ = nullptr;
  return temp;
}
inline ::yune::Type* Type_Fn::_internal_mutable_argumenttype() {
  
  if (argumenttype_ == nullptr) {
    auto* p = CreateMaybeMessage<::yune::Type>(GetArenaForAllocation());
    argumenttype_ = p;
  }
  return argumenttype_;
}
inline ::yune::Type* Type_Fn::mutable_argumenttype() {
  ::yune::Type* _msg = _internal_mutable_argumenttype();
  // @@protoc_insertion_point(field_mutable:yune.Type.Fn.argumentType)
  return _msg;
}
inline void Type_Fn::set_allocated_argumenttype(::yune::Type* argumenttype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete argumenttype_;
  }
  if (argumenttype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::yune::Type>::GetOwningArena(argumenttype);
    if (message_arena != submessage_arena) {
      argumenttype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, argumenttype, submessage_arena);
    }
    
  } else {
    
  }
  argumenttype_ = argumenttype;
  // @@protoc_insertion_point(field_set_allocated:yune.Type.Fn.argumentType)
}

// .yune.Type returnType = 2;
inline bool Type_Fn::_internal_has_returntype() const {
  return this != internal_default_instance() && returntype_ != nullptr;
}
inline bool Type_Fn::has_returntype() const {
  return _internal_has_returntype();
}
inline void Type_Fn::clear_returntype() {
  if (GetArenaForAllocation() == nullptr && returntype_ != nullptr) {
    delete returntype_;
  }
  returntype_ = nullptr;
}
inline const ::yune::Type& Type_Fn::_internal_returntype() const {
  const ::yune::Type* p = returntype_;
  return p != nullptr ? *p : reinterpret_cast<const ::yune::Type&>(
      ::yune::_Type_default_instance_);
}
inline const ::yune::Type& Type_Fn::returntype() const {
  // @@protoc_insertion_point(field_get:yune.Type.Fn.returnType)
  return _internal_returntype();
}
inline void Type_Fn::unsafe_arena_set_allocated_returntype(
    ::yune::Type* returntype) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(returntype_);
  }
  returntype_ = returntype;
  if (returntype) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:yune.Type.Fn.returnType)
}
inline ::yune::Type* Type_Fn::release_returntype() {
  
  ::yune::Type* temp = returntype_;
  returntype_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::yune::Type* Type_Fn::unsafe_arena_release_returntype() {
  // @@protoc_insertion_point(field_release:yune.Type.Fn.returnType)
  
  ::yune::Type* temp = returntype_;
  returntype_ = nullptr;
  return temp;
}
inline ::yune::Type* Type_Fn::_internal_mutable_returntype() {
  
  if (returntype_ == nullptr) {
    auto* p = CreateMaybeMessage<::yune::Type>(GetArenaForAllocation());
    returntype_ = p;
  }
  return returntype_;
}
inline ::yune::Type* Type_Fn::mutable_returntype() {
  ::yune::Type* _msg = _internal_mutable_returntype();
  // @@protoc_insertion_point(field_mutable:yune.Type.Fn.returnType)
  return _msg;
}
inline void Type_Fn::set_allocated_returntype(::yune::Type* returntype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete returntype_;
  }
  if (returntype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::yune::Type>::GetOwningArena(returntype);
    if (message_arena != submessage_arena) {
      returntype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, returntype, submessage_arena);
    }
    
  } else {
    
  }
  returntype_ = returntype;
  // @@protoc_insertion_point(field_set_allocated:yune.Type.Fn.returnType)
}

// -------------------------------------------------------------------

// Type_Tuple

// repeated .yune.Type elements = 1;
inline int Type_Tuple::_internal_elements_size() const {
  return elements_.size();
}
inline int Type_Tuple::elements_size() const {
  return _internal_elements_size();
}
inline void Type_Tuple::clear_elements() {
  elements_.Clear();
}
inline ::yune::Type* Type_Tuple::mutable_elements(int index) {
  // @@protoc_insertion_point(field_mutable:yune.Type.Tuple.elements)
  return elements_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::yune::Type >*
Type_Tuple::mutable_elements() {
  // @@protoc_insertion_point(field_mutable_list:yune.Type.Tuple.elements)
  return &elements_;
}
inline const ::yune::Type& Type_Tuple::_internal_elements(int index) const {
  return elements_.Get(index);
}
inline const ::yune::Type& Type_Tuple::elements(int index) const {
  // @@protoc_insertion_point(field_get:yune.Type.Tuple.elements)
  return _internal_elements(index);
}
inline ::yune::Type* Type_Tuple::_internal_add_elements() {
  return elements_.Add();
}
inline ::yune::Type* Type_Tuple::add_elements() {
  ::yune::Type* _add = _internal_add_elements();
  // @@protoc_insertion_point(field_add:yune.Type.Tuple.elements)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::yune::Type >&
Type_Tuple::elements() const {
  // @@protoc_insertion_point(field_list:yune.Type.Tuple.elements)
  return elements_;
}

// -------------------------------------------------------------------

// Type_List

// .yune.Type element = 1;
inline bool Type_List::_internal_has_element() const {
  return this != internal_default_instance() && element_ != nullptr;
}
inline bool Type_List::has_element() const {
  return _internal_has_element();
}
inline void Type_List::clear_element() {
  if (GetArenaForAllocation() == nullptr && element_ != nullptr) {
    delete element_;
  }
  element_ = nullptr;
}
inline const ::yune::Type& Type_List::_internal_element() const {
  const ::yune::Type* p = element_;
  return p != nullptr ? *p : reinterpret_cast<const ::yune::Type&>(
      ::yune::_Type_default_instance_);
}
inline const ::yune::Type& Type_List::element() const {
  // @@protoc_insertion_point(field_get:yune.Type.List.element)
  return _internal_element();
}
inline void Type_List::unsafe_arena_set_allocated_element(
    ::yune::Type* element) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(element_);
  }
  element_ = element;
  if (element) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:yune.Type.List.element)
}
inline ::yune::Type* Type_List::release_element() {
  
  ::yune::Type* temp = element_;
  element_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::yune::Type* Type_List::unsafe_arena_release_element() {
  // @@protoc_insertion_point(field_release:yune.Type.List.element)
  
  ::yune::Type* temp = element_;
  element_ = nullptr;
  return temp;
}
inline ::yune::Type* Type_List::_internal_mutable_element() {
  
  if (element_ == nullptr) {
    auto* p = CreateMaybeMessage<::yune::Type>(GetArenaForAllocation());
    element_ = p;
  }
  return element_;
}
inline ::yune::Type* Type_List::mutable_element() {
  ::yune::Type* _msg = _internal_mutable_element();
  // @@protoc_insertion_point(field_mutable:yune.Type.List.element)
  return _msg;
}
inline void Type_List::set_allocated_element(::yune::Type* element) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete element_;
  }
  if (element) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::yune::Type>::GetOwningArena(element);
    if (message_arena != submessage_arena) {
      element = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, element, submessage_arena);
    }
    
  } else {
    
  }
  element_ = element;
  // @@protoc_insertion_point(field_set_allocated:yune.Type.List.element)
}

// -------------------------------------------------------------------

// Type

// .yune.Type.Int int = 1;
inline bool Type::_internal_has_int_() const {
  return is_case() == kInt;
}
inline bool Type::has_int_() const {
  return _internal_has_int_();
}
inline void Type::set_has_int_() {
  _oneof_case_[0] = kInt;
}
inline void Type::clear_int_() {
  if (_internal_has_int_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete is_.int__;
    }
    clear_has_is();
  }
}
inline ::yune::Type_Int* Type::release_int_() {
  // @@protoc_insertion_point(field_release:yune.Type.int)
  if (_internal_has_int_()) {
    clear_has_is();
      ::yune::Type_Int* temp = is_.int__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    is_.int__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::yune::Type_Int& Type::_internal_int_() const {
  return _internal_has_int_()
      ? *is_.int__
      : reinterpret_cast< ::yune::Type_Int&>(::yune::_Type_Int_default_instance_);
}
inline const ::yune::Type_Int& Type::int_() const {
  // @@protoc_insertion_point(field_get:yune.Type.int)
  return _internal_int_();
}
inline ::yune::Type_Int* Type::unsafe_arena_release_int_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:yune.Type.int)
  if (_internal_has_int_()) {
    clear_has_is();
    ::yune::Type_Int* temp = is_.int__;
    is_.int__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_int_(::yune::Type_Int* int_) {
  clear_is();
  if (int_) {
    set_has_int_();
    is_.int__ = int_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:yune.Type.int)
}
inline ::yune::Type_Int* Type::_internal_mutable_int_() {
  if (!_internal_has_int_()) {
    clear_is();
    set_has_int_();
    is_.int__ = CreateMaybeMessage< ::yune::Type_Int >(GetArenaForAllocation());
  }
  return is_.int__;
}
inline ::yune::Type_Int* Type::mutable_int_() {
  ::yune::Type_Int* _msg = _internal_mutable_int_();
  // @@protoc_insertion_point(field_mutable:yune.Type.int)
  return _msg;
}

// .yune.Type.Float float = 2;
inline bool Type::_internal_has_float_() const {
  return is_case() == kFloat;
}
inline bool Type::has_float_() const {
  return _internal_has_float_();
}
inline void Type::set_has_float_() {
  _oneof_case_[0] = kFloat;
}
inline void Type::clear_float_() {
  if (_internal_has_float_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete is_.float__;
    }
    clear_has_is();
  }
}
inline ::yune::Type_Float* Type::release_float_() {
  // @@protoc_insertion_point(field_release:yune.Type.float)
  if (_internal_has_float_()) {
    clear_has_is();
      ::yune::Type_Float* temp = is_.float__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    is_.float__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::yune::Type_Float& Type::_internal_float_() const {
  return _internal_has_float_()
      ? *is_.float__
      : reinterpret_cast< ::yune::Type_Float&>(::yune::_Type_Float_default_instance_);
}
inline const ::yune::Type_Float& Type::float_() const {
  // @@protoc_insertion_point(field_get:yune.Type.float)
  return _internal_float_();
}
inline ::yune::Type_Float* Type::unsafe_arena_release_float_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:yune.Type.float)
  if (_internal_has_float_()) {
    clear_has_is();
    ::yune::Type_Float* temp = is_.float__;
    is_.float__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_float_(::yune::Type_Float* float_) {
  clear_is();
  if (float_) {
    set_has_float_();
    is_.float__ = float_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:yune.Type.float)
}
inline ::yune::Type_Float* Type::_internal_mutable_float_() {
  if (!_internal_has_float_()) {
    clear_is();
    set_has_float_();
    is_.float__ = CreateMaybeMessage< ::yune::Type_Float >(GetArenaForAllocation());
  }
  return is_.float__;
}
inline ::yune::Type_Float* Type::mutable_float_() {
  ::yune::Type_Float* _msg = _internal_mutable_float_();
  // @@protoc_insertion_point(field_mutable:yune.Type.float)
  return _msg;
}

// .yune.Type.Bool bool = 3;
inline bool Type::_internal_has_bool_() const {
  return is_case() == kBool;
}
inline bool Type::has_bool_() const {
  return _internal_has_bool_();
}
inline void Type::set_has_bool_() {
  _oneof_case_[0] = kBool;
}
inline void Type::clear_bool_() {
  if (_internal_has_bool_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete is_.bool__;
    }
    clear_has_is();
  }
}
inline ::yune::Type_Bool* Type::release_bool_() {
  // @@protoc_insertion_point(field_release:yune.Type.bool)
  if (_internal_has_bool_()) {
    clear_has_is();
      ::yune::Type_Bool* temp = is_.bool__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    is_.bool__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::yune::Type_Bool& Type::_internal_bool_() const {
  return _internal_has_bool_()
      ? *is_.bool__
      : reinterpret_cast< ::yune::Type_Bool&>(::yune::_Type_Bool_default_instance_);
}
inline const ::yune::Type_Bool& Type::bool_() const {
  // @@protoc_insertion_point(field_get:yune.Type.bool)
  return _internal_bool_();
}
inline ::yune::Type_Bool* Type::unsafe_arena_release_bool_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:yune.Type.bool)
  if (_internal_has_bool_()) {
    clear_has_is();
    ::yune::Type_Bool* temp = is_.bool__;
    is_.bool__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_bool_(::yune::Type_Bool* bool_) {
  clear_is();
  if (bool_) {
    set_has_bool_();
    is_.bool__ = bool_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:yune.Type.bool)
}
inline ::yune::Type_Bool* Type::_internal_mutable_bool_() {
  if (!_internal_has_bool_()) {
    clear_is();
    set_has_bool_();
    is_.bool__ = CreateMaybeMessage< ::yune::Type_Bool >(GetArenaForAllocation());
  }
  return is_.bool__;
}
inline ::yune::Type_Bool* Type::mutable_bool_() {
  ::yune::Type_Bool* _msg = _internal_mutable_bool_();
  // @@protoc_insertion_point(field_mutable:yune.Type.bool)
  return _msg;
}

// .yune.Type.String string = 4;
inline bool Type::_internal_has_string() const {
  return is_case() == kString;
}
inline bool Type::has_string() const {
  return _internal_has_string();
}
inline void Type::set_has_string() {
  _oneof_case_[0] = kString;
}
inline void Type::clear_string() {
  if (_internal_has_string()) {
    if (GetArenaForAllocation() == nullptr) {
      delete is_.string_;
    }
    clear_has_is();
  }
}
inline ::yune::Type_String* Type::release_string() {
  // @@protoc_insertion_point(field_release:yune.Type.string)
  if (_internal_has_string()) {
    clear_has_is();
      ::yune::Type_String* temp = is_.string_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    is_.string_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::yune::Type_String& Type::_internal_string() const {
  return _internal_has_string()
      ? *is_.string_
      : reinterpret_cast< ::yune::Type_String&>(::yune::_Type_String_default_instance_);
}
inline const ::yune::Type_String& Type::string() const {
  // @@protoc_insertion_point(field_get:yune.Type.string)
  return _internal_string();
}
inline ::yune::Type_String* Type::unsafe_arena_release_string() {
  // @@protoc_insertion_point(field_unsafe_arena_release:yune.Type.string)
  if (_internal_has_string()) {
    clear_has_is();
    ::yune::Type_String* temp = is_.string_;
    is_.string_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_string(::yune::Type_String* string) {
  clear_is();
  if (string) {
    set_has_string();
    is_.string_ = string;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:yune.Type.string)
}
inline ::yune::Type_String* Type::_internal_mutable_string() {
  if (!_internal_has_string()) {
    clear_is();
    set_has_string();
    is_.string_ = CreateMaybeMessage< ::yune::Type_String >(GetArenaForAllocation());
  }
  return is_.string_;
}
inline ::yune::Type_String* Type::mutable_string() {
  ::yune::Type_String* _msg = _internal_mutable_string();
  // @@protoc_insertion_point(field_mutable:yune.Type.string)
  return _msg;
}

// .yune.Type.Fn fn = 5;
inline bool Type::_internal_has_fn() const {
  return is_case() == kFn;
}
inline bool Type::has_fn() const {
  return _internal_has_fn();
}
inline void Type::set_has_fn() {
  _oneof_case_[0] = kFn;
}
inline void Type::clear_fn() {
  if (_internal_has_fn()) {
    if (GetArenaForAllocation() == nullptr) {
      delete is_.fn_;
    }
    clear_has_is();
  }
}
inline ::yune::Type_Fn* Type::release_fn() {
  // @@protoc_insertion_point(field_release:yune.Type.fn)
  if (_internal_has_fn()) {
    clear_has_is();
      ::yune::Type_Fn* temp = is_.fn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    is_.fn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::yune::Type_Fn& Type::_internal_fn() const {
  return _internal_has_fn()
      ? *is_.fn_
      : reinterpret_cast< ::yune::Type_Fn&>(::yune::_Type_Fn_default_instance_);
}
inline const ::yune::Type_Fn& Type::fn() const {
  // @@protoc_insertion_point(field_get:yune.Type.fn)
  return _internal_fn();
}
inline ::yune::Type_Fn* Type::unsafe_arena_release_fn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:yune.Type.fn)
  if (_internal_has_fn()) {
    clear_has_is();
    ::yune::Type_Fn* temp = is_.fn_;
    is_.fn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_fn(::yune::Type_Fn* fn) {
  clear_is();
  if (fn) {
    set_has_fn();
    is_.fn_ = fn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:yune.Type.fn)
}
inline ::yune::Type_Fn* Type::_internal_mutable_fn() {
  if (!_internal_has_fn()) {
    clear_is();
    set_has_fn();
    is_.fn_ = CreateMaybeMessage< ::yune::Type_Fn >(GetArenaForAllocation());
  }
  return is_.fn_;
}
inline ::yune::Type_Fn* Type::mutable_fn() {
  ::yune::Type_Fn* _msg = _internal_mutable_fn();
  // @@protoc_insertion_point(field_mutable:yune.Type.fn)
  return _msg;
}

// .yune.Type.Tuple tuple = 6;
inline bool Type::_internal_has_tuple() const {
  return is_case() == kTuple;
}
inline bool Type::has_tuple() const {
  return _internal_has_tuple();
}
inline void Type::set_has_tuple() {
  _oneof_case_[0] = kTuple;
}
inline void Type::clear_tuple() {
  if (_internal_has_tuple()) {
    if (GetArenaForAllocation() == nullptr) {
      delete is_.tuple_;
    }
    clear_has_is();
  }
}
inline ::yune::Type_Tuple* Type::release_tuple() {
  // @@protoc_insertion_point(field_release:yune.Type.tuple)
  if (_internal_has_tuple()) {
    clear_has_is();
      ::yune::Type_Tuple* temp = is_.tuple_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    is_.tuple_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::yune::Type_Tuple& Type::_internal_tuple() const {
  return _internal_has_tuple()
      ? *is_.tuple_
      : reinterpret_cast< ::yune::Type_Tuple&>(::yune::_Type_Tuple_default_instance_);
}
inline const ::yune::Type_Tuple& Type::tuple() const {
  // @@protoc_insertion_point(field_get:yune.Type.tuple)
  return _internal_tuple();
}
inline ::yune::Type_Tuple* Type::unsafe_arena_release_tuple() {
  // @@protoc_insertion_point(field_unsafe_arena_release:yune.Type.tuple)
  if (_internal_has_tuple()) {
    clear_has_is();
    ::yune::Type_Tuple* temp = is_.tuple_;
    is_.tuple_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_tuple(::yune::Type_Tuple* tuple) {
  clear_is();
  if (tuple) {
    set_has_tuple();
    is_.tuple_ = tuple;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:yune.Type.tuple)
}
inline ::yune::Type_Tuple* Type::_internal_mutable_tuple() {
  if (!_internal_has_tuple()) {
    clear_is();
    set_has_tuple();
    is_.tuple_ = CreateMaybeMessage< ::yune::Type_Tuple >(GetArenaForAllocation());
  }
  return is_.tuple_;
}
inline ::yune::Type_Tuple* Type::mutable_tuple() {
  ::yune::Type_Tuple* _msg = _internal_mutable_tuple();
  // @@protoc_insertion_point(field_mutable:yune.Type.tuple)
  return _msg;
}

// .yune.Type.List list = 7;
inline bool Type::_internal_has_list() const {
  return is_case() == kList;
}
inline bool Type::has_list() const {
  return _internal_has_list();
}
inline void Type::set_has_list() {
  _oneof_case_[0] = kList;
}
inline void Type::clear_list() {
  if (_internal_has_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete is_.list_;
    }
    clear_has_is();
  }
}
inline ::yune::Type_List* Type::release_list() {
  // @@protoc_insertion_point(field_release:yune.Type.list)
  if (_internal_has_list()) {
    clear_has_is();
      ::yune::Type_List* temp = is_.list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    is_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::yune::Type_List& Type::_internal_list() const {
  return _internal_has_list()
      ? *is_.list_
      : reinterpret_cast< ::yune::Type_List&>(::yune::_Type_List_default_instance_);
}
inline const ::yune::Type_List& Type::list() const {
  // @@protoc_insertion_point(field_get:yune.Type.list)
  return _internal_list();
}
inline ::yune::Type_List* Type::unsafe_arena_release_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:yune.Type.list)
  if (_internal_has_list()) {
    clear_has_is();
    ::yune::Type_List* temp = is_.list_;
    is_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_list(::yune::Type_List* list) {
  clear_is();
  if (list) {
    set_has_list();
    is_.list_ = list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:yune.Type.list)
}
inline ::yune::Type_List* Type::_internal_mutable_list() {
  if (!_internal_has_list()) {
    clear_is();
    set_has_list();
    is_.list_ = CreateMaybeMessage< ::yune::Type_List >(GetArenaForAllocation());
  }
  return is_.list_;
}
inline ::yune::Type_List* Type::mutable_list() {
  ::yune::Type_List* _msg = _internal_mutable_list();
  // @@protoc_insertion_point(field_mutable:yune.Type.list)
  return _msg;
}

inline bool Type::has_is() const {
  return is_case() != IS_NOT_SET;
}
inline void Type::clear_has_is() {
  _oneof_case_[0] = IS_NOT_SET;
}
inline Type::IsCase Type::is_case() const {
  return Type::IsCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace yune

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proto_2ftype_2eproto
