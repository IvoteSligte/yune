// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/type.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2ftype_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proto_2ftype_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2ftype_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2ftype_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proto_2ftype_2eproto;
namespace yune {
class Messages;
struct MessagesDefaultTypeInternal;
extern MessagesDefaultTypeInternal _Messages_default_instance_;
class Type;
struct TypeDefaultTypeInternal;
extern TypeDefaultTypeInternal _Type_default_instance_;
class Type_Fn;
struct Type_FnDefaultTypeInternal;
extern Type_FnDefaultTypeInternal _Type_Fn_default_instance_;
class Type_List;
struct Type_ListDefaultTypeInternal;
extern Type_ListDefaultTypeInternal _Type_List_default_instance_;
class Type_Struct;
struct Type_StructDefaultTypeInternal;
extern Type_StructDefaultTypeInternal _Type_Struct_default_instance_;
class Type_Tuple;
struct Type_TupleDefaultTypeInternal;
extern Type_TupleDefaultTypeInternal _Type_Tuple_default_instance_;
}  // namespace yune
PROTOBUF_NAMESPACE_OPEN
template<> ::yune::Messages* Arena::CreateMaybeMessage<::yune::Messages>(Arena*);
template<> ::yune::Type* Arena::CreateMaybeMessage<::yune::Type>(Arena*);
template<> ::yune::Type_Fn* Arena::CreateMaybeMessage<::yune::Type_Fn>(Arena*);
template<> ::yune::Type_List* Arena::CreateMaybeMessage<::yune::Type_List>(Arena*);
template<> ::yune::Type_Struct* Arena::CreateMaybeMessage<::yune::Type_Struct>(Arena*);
template<> ::yune::Type_Tuple* Arena::CreateMaybeMessage<::yune::Type_Tuple>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace yune {

enum Type_Kind : int {
  Type_Kind_TYPE = 0,
  Type_Kind_INT = 1,
  Type_Kind_FLOAT = 2,
  Type_Kind_BOOL = 3,
  Type_Kind_STRING = 4,
  Type_Kind_NIL = 5,
  Type_Kind_FN = 6,
  Type_Kind_TUPLE = 7,
  Type_Kind_LIST = 8,
  Type_Kind_STRUCT = 9,
  Type_Kind_Type_Kind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Type_Kind_Type_Kind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Type_Kind_IsValid(int value);
constexpr Type_Kind Type_Kind_Kind_MIN = Type_Kind_TYPE;
constexpr Type_Kind Type_Kind_Kind_MAX = Type_Kind_STRUCT;
constexpr int Type_Kind_Kind_ARRAYSIZE = Type_Kind_Kind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Type_Kind_descriptor();
template<typename T>
inline const std::string& Type_Kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Type_Kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Type_Kind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Type_Kind_descriptor(), enum_t_value);
}
inline bool Type_Kind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Type_Kind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Type_Kind>(
    Type_Kind_descriptor(), name, value);
}
// ===================================================================

class Type_Fn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:yune.Type.Fn) */ {
 public:
  inline Type_Fn() : Type_Fn(nullptr) {}
  ~Type_Fn() override;
  explicit constexpr Type_Fn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_Fn(const Type_Fn& from);
  Type_Fn(Type_Fn&& from) noexcept
    : Type_Fn() {
    *this = ::std::move(from);
  }

  inline Type_Fn& operator=(const Type_Fn& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_Fn& operator=(Type_Fn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_Fn& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_Fn* internal_default_instance() {
    return reinterpret_cast<const Type_Fn*>(
               &_Type_Fn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Type_Fn& a, Type_Fn& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_Fn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_Fn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_Fn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_Fn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_Fn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_Fn& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_Fn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "yune.Type.Fn";
  }
  protected:
  explicit Type_Fn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgumentTypeFieldNumber = 1,
    kReturnTypeFieldNumber = 2,
  };
  // .yune.Type argumentType = 1;
  bool has_argumenttype() const;
  private:
  bool _internal_has_argumenttype() const;
  public:
  void clear_argumenttype();
  const ::yune::Type& argumenttype() const;
  PROTOBUF_NODISCARD ::yune::Type* release_argumenttype();
  ::yune::Type* mutable_argumenttype();
  void set_allocated_argumenttype(::yune::Type* argumenttype);
  private:
  const ::yune::Type& _internal_argumenttype() const;
  ::yune::Type* _internal_mutable_argumenttype();
  public:
  void unsafe_arena_set_allocated_argumenttype(
      ::yune::Type* argumenttype);
  ::yune::Type* unsafe_arena_release_argumenttype();

  // .yune.Type returnType = 2;
  bool has_returntype() const;
  private:
  bool _internal_has_returntype() const;
  public:
  void clear_returntype();
  const ::yune::Type& returntype() const;
  PROTOBUF_NODISCARD ::yune::Type* release_returntype();
  ::yune::Type* mutable_returntype();
  void set_allocated_returntype(::yune::Type* returntype);
  private:
  const ::yune::Type& _internal_returntype() const;
  ::yune::Type* _internal_mutable_returntype();
  public:
  void unsafe_arena_set_allocated_returntype(
      ::yune::Type* returntype);
  ::yune::Type* unsafe_arena_release_returntype();

  // @@protoc_insertion_point(class_scope:yune.Type.Fn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::yune::Type* argumenttype_;
  ::yune::Type* returntype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_Tuple final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:yune.Type.Tuple) */ {
 public:
  inline Type_Tuple() : Type_Tuple(nullptr) {}
  ~Type_Tuple() override;
  explicit constexpr Type_Tuple(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_Tuple(const Type_Tuple& from);
  Type_Tuple(Type_Tuple&& from) noexcept
    : Type_Tuple() {
    *this = ::std::move(from);
  }

  inline Type_Tuple& operator=(const Type_Tuple& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_Tuple& operator=(Type_Tuple&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_Tuple& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_Tuple* internal_default_instance() {
    return reinterpret_cast<const Type_Tuple*>(
               &_Type_Tuple_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Type_Tuple& a, Type_Tuple& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_Tuple* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_Tuple* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_Tuple* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_Tuple>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_Tuple& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_Tuple& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_Tuple* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "yune.Type.Tuple";
  }
  protected:
  explicit Type_Tuple(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElementsFieldNumber = 1,
  };
  // repeated .yune.Type elements = 1;
  int elements_size() const;
  private:
  int _internal_elements_size() const;
  public:
  void clear_elements();
  ::yune::Type* mutable_elements(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::yune::Type >*
      mutable_elements();
  private:
  const ::yune::Type& _internal_elements(int index) const;
  ::yune::Type* _internal_add_elements();
  public:
  const ::yune::Type& elements(int index) const;
  ::yune::Type* add_elements();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::yune::Type >&
      elements() const;

  // @@protoc_insertion_point(class_scope:yune.Type.Tuple)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::yune::Type > elements_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_List final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:yune.Type.List) */ {
 public:
  inline Type_List() : Type_List(nullptr) {}
  ~Type_List() override;
  explicit constexpr Type_List(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_List(const Type_List& from);
  Type_List(Type_List&& from) noexcept
    : Type_List() {
    *this = ::std::move(from);
  }

  inline Type_List& operator=(const Type_List& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_List& operator=(Type_List&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_List& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_List* internal_default_instance() {
    return reinterpret_cast<const Type_List*>(
               &_Type_List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Type_List& a, Type_List& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_List* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_List* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_List>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_List& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_List& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_List* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "yune.Type.List";
  }
  protected:
  explicit Type_List(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElementFieldNumber = 1,
  };
  // .yune.Type element = 1;
  bool has_element() const;
  private:
  bool _internal_has_element() const;
  public:
  void clear_element();
  const ::yune::Type& element() const;
  PROTOBUF_NODISCARD ::yune::Type* release_element();
  ::yune::Type* mutable_element();
  void set_allocated_element(::yune::Type* element);
  private:
  const ::yune::Type& _internal_element() const;
  ::yune::Type* _internal_mutable_element();
  public:
  void unsafe_arena_set_allocated_element(
      ::yune::Type* element);
  ::yune::Type* unsafe_arena_release_element();

  // @@protoc_insertion_point(class_scope:yune.Type.List)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::yune::Type* element_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type_Struct final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:yune.Type.Struct) */ {
 public:
  inline Type_Struct() : Type_Struct(nullptr) {}
  ~Type_Struct() override;
  explicit constexpr Type_Struct(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type_Struct(const Type_Struct& from);
  Type_Struct(Type_Struct&& from) noexcept
    : Type_Struct() {
    *this = ::std::move(from);
  }

  inline Type_Struct& operator=(const Type_Struct& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type_Struct& operator=(Type_Struct&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type_Struct& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type_Struct* internal_default_instance() {
    return reinterpret_cast<const Type_Struct*>(
               &_Type_Struct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Type_Struct& a, Type_Struct& b) {
    a.Swap(&b);
  }
  inline void Swap(Type_Struct* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type_Struct* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type_Struct* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type_Struct>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type_Struct& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type_Struct& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_Struct* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "yune.Type.Struct";
  }
  protected:
  explicit Type_Struct(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:yune.Type.Struct)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Type final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:yune.Type) */ {
 public:
  inline Type() : Type(nullptr) {}
  ~Type() override;
  explicit constexpr Type(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type(const Type& from);
  Type(Type&& from) noexcept
    : Type() {
    *this = ::std::move(from);
  }

  inline Type& operator=(const Type& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type& operator=(Type&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type& default_instance() {
    return *internal_default_instance();
  }
  enum DetailCase {
    kFn = 2,
    kTuple = 3,
    kList = 4,
    kStruct = 5,
    DETAIL_NOT_SET = 0,
  };

  static inline const Type* internal_default_instance() {
    return reinterpret_cast<const Type*>(
               &_Type_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Type& a, Type& b) {
    a.Swap(&b);
  }
  inline void Swap(Type* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Type& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "yune.Type";
  }
  protected:
  explicit Type(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Type_Fn Fn;
  typedef Type_Tuple Tuple;
  typedef Type_List List;
  typedef Type_Struct Struct;

  typedef Type_Kind Kind;
  static constexpr Kind TYPE =
    Type_Kind_TYPE;
  static constexpr Kind INT =
    Type_Kind_INT;
  static constexpr Kind FLOAT =
    Type_Kind_FLOAT;
  static constexpr Kind BOOL =
    Type_Kind_BOOL;
  static constexpr Kind STRING =
    Type_Kind_STRING;
  static constexpr Kind NIL =
    Type_Kind_NIL;
  static constexpr Kind FN =
    Type_Kind_FN;
  static constexpr Kind TUPLE =
    Type_Kind_TUPLE;
  static constexpr Kind LIST =
    Type_Kind_LIST;
  static constexpr Kind STRUCT =
    Type_Kind_STRUCT;
  static inline bool Kind_IsValid(int value) {
    return Type_Kind_IsValid(value);
  }
  static constexpr Kind Kind_MIN =
    Type_Kind_Kind_MIN;
  static constexpr Kind Kind_MAX =
    Type_Kind_Kind_MAX;
  static constexpr int Kind_ARRAYSIZE =
    Type_Kind_Kind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Kind_descriptor() {
    return Type_Kind_descriptor();
  }
  template<typename T>
  static inline const std::string& Kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Kind_Name.");
    return Type_Kind_Name(enum_t_value);
  }
  static inline bool Kind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Kind* value) {
    return Type_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kKindFieldNumber = 1,
    kFnFieldNumber = 2,
    kTupleFieldNumber = 3,
    kListFieldNumber = 4,
    kStructFieldNumber = 5,
  };
  // .yune.Type.Kind kind = 1;
  void clear_kind();
  ::yune::Type_Kind kind() const;
  void set_kind(::yune::Type_Kind value);
  private:
  ::yune::Type_Kind _internal_kind() const;
  void _internal_set_kind(::yune::Type_Kind value);
  public:

  // .yune.Type.Fn fn = 2;
  bool has_fn() const;
  private:
  bool _internal_has_fn() const;
  public:
  void clear_fn();
  const ::yune::Type_Fn& fn() const;
  PROTOBUF_NODISCARD ::yune::Type_Fn* release_fn();
  ::yune::Type_Fn* mutable_fn();
  void set_allocated_fn(::yune::Type_Fn* fn);
  private:
  const ::yune::Type_Fn& _internal_fn() const;
  ::yune::Type_Fn* _internal_mutable_fn();
  public:
  void unsafe_arena_set_allocated_fn(
      ::yune::Type_Fn* fn);
  ::yune::Type_Fn* unsafe_arena_release_fn();

  // .yune.Type.Tuple tuple = 3;
  bool has_tuple() const;
  private:
  bool _internal_has_tuple() const;
  public:
  void clear_tuple();
  const ::yune::Type_Tuple& tuple() const;
  PROTOBUF_NODISCARD ::yune::Type_Tuple* release_tuple();
  ::yune::Type_Tuple* mutable_tuple();
  void set_allocated_tuple(::yune::Type_Tuple* tuple);
  private:
  const ::yune::Type_Tuple& _internal_tuple() const;
  ::yune::Type_Tuple* _internal_mutable_tuple();
  public:
  void unsafe_arena_set_allocated_tuple(
      ::yune::Type_Tuple* tuple);
  ::yune::Type_Tuple* unsafe_arena_release_tuple();

  // .yune.Type.List list = 4;
  bool has_list() const;
  private:
  bool _internal_has_list() const;
  public:
  void clear_list();
  const ::yune::Type_List& list() const;
  PROTOBUF_NODISCARD ::yune::Type_List* release_list();
  ::yune::Type_List* mutable_list();
  void set_allocated_list(::yune::Type_List* list);
  private:
  const ::yune::Type_List& _internal_list() const;
  ::yune::Type_List* _internal_mutable_list();
  public:
  void unsafe_arena_set_allocated_list(
      ::yune::Type_List* list);
  ::yune::Type_List* unsafe_arena_release_list();

  // .yune.Type.Struct struct = 5;
  bool has_struct_() const;
  private:
  bool _internal_has_struct_() const;
  public:
  void clear_struct_();
  const ::yune::Type_Struct& struct_() const;
  PROTOBUF_NODISCARD ::yune::Type_Struct* release_struct_();
  ::yune::Type_Struct* mutable_struct_();
  void set_allocated_struct_(::yune::Type_Struct* struct_);
  private:
  const ::yune::Type_Struct& _internal_struct_() const;
  ::yune::Type_Struct* _internal_mutable_struct_();
  public:
  void unsafe_arena_set_allocated_struct_(
      ::yune::Type_Struct* struct_);
  ::yune::Type_Struct* unsafe_arena_release_struct_();

  void clear_Detail();
  DetailCase Detail_case() const;
  // @@protoc_insertion_point(class_scope:yune.Type)
 private:
  class _Internal;
  void set_has_fn();
  void set_has_tuple();
  void set_has_list();
  void set_has_struct_();

  inline bool has_Detail() const;
  inline void clear_has_Detail();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int kind_;
  union DetailUnion {
    constexpr DetailUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::yune::Type_Fn* fn_;
    ::yune::Type_Tuple* tuple_;
    ::yune::Type_List* list_;
    ::yune::Type_Struct* struct__;
  } Detail_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_proto_2ftype_2eproto;
};
// -------------------------------------------------------------------

class Messages final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:yune.Messages) */ {
 public:
  inline Messages() : Messages(nullptr) {}
  ~Messages() override;
  explicit constexpr Messages(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Messages(const Messages& from);
  Messages(Messages&& from) noexcept
    : Messages() {
    *this = ::std::move(from);
  }

  inline Messages& operator=(const Messages& from) {
    CopyFrom(from);
    return *this;
  }
  inline Messages& operator=(Messages&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Messages& default_instance() {
    return *internal_default_instance();
  }
  static inline const Messages* internal_default_instance() {
    return reinterpret_cast<const Messages*>(
               &_Messages_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Messages& a, Messages& b) {
    a.Swap(&b);
  }
  inline void Swap(Messages* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Messages* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Messages* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Messages>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Messages& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Messages& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Messages* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "yune.Messages";
  }
  protected:
  explicit Messages(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 1,
  };
  // repeated .google.protobuf.Any messages = 1;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_messages();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_messages(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_add_messages();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Any& messages(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
      messages() const;

  // @@protoc_insertion_point(class_scope:yune.Messages)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any > messages_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2ftype_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Type_Fn

// .yune.Type argumentType = 1;
inline bool Type_Fn::_internal_has_argumenttype() const {
  return this != internal_default_instance() && argumenttype_ != nullptr;
}
inline bool Type_Fn::has_argumenttype() const {
  return _internal_has_argumenttype();
}
inline void Type_Fn::clear_argumenttype() {
  if (GetArenaForAllocation() == nullptr && argumenttype_ != nullptr) {
    delete argumenttype_;
  }
  argumenttype_ = nullptr;
}
inline const ::yune::Type& Type_Fn::_internal_argumenttype() const {
  const ::yune::Type* p = argumenttype_;
  return p != nullptr ? *p : reinterpret_cast<const ::yune::Type&>(
      ::yune::_Type_default_instance_);
}
inline const ::yune::Type& Type_Fn::argumenttype() const {
  // @@protoc_insertion_point(field_get:yune.Type.Fn.argumentType)
  return _internal_argumenttype();
}
inline void Type_Fn::unsafe_arena_set_allocated_argumenttype(
    ::yune::Type* argumenttype) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(argumenttype_);
  }
  argumenttype_ = argumenttype;
  if (argumenttype) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:yune.Type.Fn.argumentType)
}
inline ::yune::Type* Type_Fn::release_argumenttype() {
  
  ::yune::Type* temp = argumenttype_;
  argumenttype_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::yune::Type* Type_Fn::unsafe_arena_release_argumenttype() {
  // @@protoc_insertion_point(field_release:yune.Type.Fn.argumentType)
  
  ::yune::Type* temp = argumenttype_;
  argumenttype_ = nullptr;
  return temp;
}
inline ::yune::Type* Type_Fn::_internal_mutable_argumenttype() {
  
  if (argumenttype_ == nullptr) {
    auto* p = CreateMaybeMessage<::yune::Type>(GetArenaForAllocation());
    argumenttype_ = p;
  }
  return argumenttype_;
}
inline ::yune::Type* Type_Fn::mutable_argumenttype() {
  ::yune::Type* _msg = _internal_mutable_argumenttype();
  // @@protoc_insertion_point(field_mutable:yune.Type.Fn.argumentType)
  return _msg;
}
inline void Type_Fn::set_allocated_argumenttype(::yune::Type* argumenttype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete argumenttype_;
  }
  if (argumenttype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::yune::Type>::GetOwningArena(argumenttype);
    if (message_arena != submessage_arena) {
      argumenttype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, argumenttype, submessage_arena);
    }
    
  } else {
    
  }
  argumenttype_ = argumenttype;
  // @@protoc_insertion_point(field_set_allocated:yune.Type.Fn.argumentType)
}

// .yune.Type returnType = 2;
inline bool Type_Fn::_internal_has_returntype() const {
  return this != internal_default_instance() && returntype_ != nullptr;
}
inline bool Type_Fn::has_returntype() const {
  return _internal_has_returntype();
}
inline void Type_Fn::clear_returntype() {
  if (GetArenaForAllocation() == nullptr && returntype_ != nullptr) {
    delete returntype_;
  }
  returntype_ = nullptr;
}
inline const ::yune::Type& Type_Fn::_internal_returntype() const {
  const ::yune::Type* p = returntype_;
  return p != nullptr ? *p : reinterpret_cast<const ::yune::Type&>(
      ::yune::_Type_default_instance_);
}
inline const ::yune::Type& Type_Fn::returntype() const {
  // @@protoc_insertion_point(field_get:yune.Type.Fn.returnType)
  return _internal_returntype();
}
inline void Type_Fn::unsafe_arena_set_allocated_returntype(
    ::yune::Type* returntype) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(returntype_);
  }
  returntype_ = returntype;
  if (returntype) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:yune.Type.Fn.returnType)
}
inline ::yune::Type* Type_Fn::release_returntype() {
  
  ::yune::Type* temp = returntype_;
  returntype_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::yune::Type* Type_Fn::unsafe_arena_release_returntype() {
  // @@protoc_insertion_point(field_release:yune.Type.Fn.returnType)
  
  ::yune::Type* temp = returntype_;
  returntype_ = nullptr;
  return temp;
}
inline ::yune::Type* Type_Fn::_internal_mutable_returntype() {
  
  if (returntype_ == nullptr) {
    auto* p = CreateMaybeMessage<::yune::Type>(GetArenaForAllocation());
    returntype_ = p;
  }
  return returntype_;
}
inline ::yune::Type* Type_Fn::mutable_returntype() {
  ::yune::Type* _msg = _internal_mutable_returntype();
  // @@protoc_insertion_point(field_mutable:yune.Type.Fn.returnType)
  return _msg;
}
inline void Type_Fn::set_allocated_returntype(::yune::Type* returntype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete returntype_;
  }
  if (returntype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::yune::Type>::GetOwningArena(returntype);
    if (message_arena != submessage_arena) {
      returntype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, returntype, submessage_arena);
    }
    
  } else {
    
  }
  returntype_ = returntype;
  // @@protoc_insertion_point(field_set_allocated:yune.Type.Fn.returnType)
}

// -------------------------------------------------------------------

// Type_Tuple

// repeated .yune.Type elements = 1;
inline int Type_Tuple::_internal_elements_size() const {
  return elements_.size();
}
inline int Type_Tuple::elements_size() const {
  return _internal_elements_size();
}
inline void Type_Tuple::clear_elements() {
  elements_.Clear();
}
inline ::yune::Type* Type_Tuple::mutable_elements(int index) {
  // @@protoc_insertion_point(field_mutable:yune.Type.Tuple.elements)
  return elements_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::yune::Type >*
Type_Tuple::mutable_elements() {
  // @@protoc_insertion_point(field_mutable_list:yune.Type.Tuple.elements)
  return &elements_;
}
inline const ::yune::Type& Type_Tuple::_internal_elements(int index) const {
  return elements_.Get(index);
}
inline const ::yune::Type& Type_Tuple::elements(int index) const {
  // @@protoc_insertion_point(field_get:yune.Type.Tuple.elements)
  return _internal_elements(index);
}
inline ::yune::Type* Type_Tuple::_internal_add_elements() {
  return elements_.Add();
}
inline ::yune::Type* Type_Tuple::add_elements() {
  ::yune::Type* _add = _internal_add_elements();
  // @@protoc_insertion_point(field_add:yune.Type.Tuple.elements)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::yune::Type >&
Type_Tuple::elements() const {
  // @@protoc_insertion_point(field_list:yune.Type.Tuple.elements)
  return elements_;
}

// -------------------------------------------------------------------

// Type_List

// .yune.Type element = 1;
inline bool Type_List::_internal_has_element() const {
  return this != internal_default_instance() && element_ != nullptr;
}
inline bool Type_List::has_element() const {
  return _internal_has_element();
}
inline void Type_List::clear_element() {
  if (GetArenaForAllocation() == nullptr && element_ != nullptr) {
    delete element_;
  }
  element_ = nullptr;
}
inline const ::yune::Type& Type_List::_internal_element() const {
  const ::yune::Type* p = element_;
  return p != nullptr ? *p : reinterpret_cast<const ::yune::Type&>(
      ::yune::_Type_default_instance_);
}
inline const ::yune::Type& Type_List::element() const {
  // @@protoc_insertion_point(field_get:yune.Type.List.element)
  return _internal_element();
}
inline void Type_List::unsafe_arena_set_allocated_element(
    ::yune::Type* element) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(element_);
  }
  element_ = element;
  if (element) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:yune.Type.List.element)
}
inline ::yune::Type* Type_List::release_element() {
  
  ::yune::Type* temp = element_;
  element_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::yune::Type* Type_List::unsafe_arena_release_element() {
  // @@protoc_insertion_point(field_release:yune.Type.List.element)
  
  ::yune::Type* temp = element_;
  element_ = nullptr;
  return temp;
}
inline ::yune::Type* Type_List::_internal_mutable_element() {
  
  if (element_ == nullptr) {
    auto* p = CreateMaybeMessage<::yune::Type>(GetArenaForAllocation());
    element_ = p;
  }
  return element_;
}
inline ::yune::Type* Type_List::mutable_element() {
  ::yune::Type* _msg = _internal_mutable_element();
  // @@protoc_insertion_point(field_mutable:yune.Type.List.element)
  return _msg;
}
inline void Type_List::set_allocated_element(::yune::Type* element) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete element_;
  }
  if (element) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::yune::Type>::GetOwningArena(element);
    if (message_arena != submessage_arena) {
      element = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, element, submessage_arena);
    }
    
  } else {
    
  }
  element_ = element;
  // @@protoc_insertion_point(field_set_allocated:yune.Type.List.element)
}

// -------------------------------------------------------------------

// Type_Struct

// string name = 1;
inline void Type_Struct::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Type_Struct::name() const {
  // @@protoc_insertion_point(field_get:yune.Type.Struct.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Type_Struct::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:yune.Type.Struct.name)
}
inline std::string* Type_Struct::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:yune.Type.Struct.name)
  return _s;
}
inline const std::string& Type_Struct::_internal_name() const {
  return name_.Get();
}
inline void Type_Struct::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Type_Struct::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Type_Struct::release_name() {
  // @@protoc_insertion_point(field_release:yune.Type.Struct.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Type_Struct::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:yune.Type.Struct.name)
}

// -------------------------------------------------------------------

// Type

// .yune.Type.Kind kind = 1;
inline void Type::clear_kind() {
  kind_ = 0;
}
inline ::yune::Type_Kind Type::_internal_kind() const {
  return static_cast< ::yune::Type_Kind >(kind_);
}
inline ::yune::Type_Kind Type::kind() const {
  // @@protoc_insertion_point(field_get:yune.Type.kind)
  return _internal_kind();
}
inline void Type::_internal_set_kind(::yune::Type_Kind value) {
  
  kind_ = value;
}
inline void Type::set_kind(::yune::Type_Kind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:yune.Type.kind)
}

// .yune.Type.Fn fn = 2;
inline bool Type::_internal_has_fn() const {
  return Detail_case() == kFn;
}
inline bool Type::has_fn() const {
  return _internal_has_fn();
}
inline void Type::set_has_fn() {
  _oneof_case_[0] = kFn;
}
inline void Type::clear_fn() {
  if (_internal_has_fn()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Detail_.fn_;
    }
    clear_has_Detail();
  }
}
inline ::yune::Type_Fn* Type::release_fn() {
  // @@protoc_insertion_point(field_release:yune.Type.fn)
  if (_internal_has_fn()) {
    clear_has_Detail();
      ::yune::Type_Fn* temp = Detail_.fn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Detail_.fn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::yune::Type_Fn& Type::_internal_fn() const {
  return _internal_has_fn()
      ? *Detail_.fn_
      : reinterpret_cast< ::yune::Type_Fn&>(::yune::_Type_Fn_default_instance_);
}
inline const ::yune::Type_Fn& Type::fn() const {
  // @@protoc_insertion_point(field_get:yune.Type.fn)
  return _internal_fn();
}
inline ::yune::Type_Fn* Type::unsafe_arena_release_fn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:yune.Type.fn)
  if (_internal_has_fn()) {
    clear_has_Detail();
    ::yune::Type_Fn* temp = Detail_.fn_;
    Detail_.fn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_fn(::yune::Type_Fn* fn) {
  clear_Detail();
  if (fn) {
    set_has_fn();
    Detail_.fn_ = fn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:yune.Type.fn)
}
inline ::yune::Type_Fn* Type::_internal_mutable_fn() {
  if (!_internal_has_fn()) {
    clear_Detail();
    set_has_fn();
    Detail_.fn_ = CreateMaybeMessage< ::yune::Type_Fn >(GetArenaForAllocation());
  }
  return Detail_.fn_;
}
inline ::yune::Type_Fn* Type::mutable_fn() {
  ::yune::Type_Fn* _msg = _internal_mutable_fn();
  // @@protoc_insertion_point(field_mutable:yune.Type.fn)
  return _msg;
}

// .yune.Type.Tuple tuple = 3;
inline bool Type::_internal_has_tuple() const {
  return Detail_case() == kTuple;
}
inline bool Type::has_tuple() const {
  return _internal_has_tuple();
}
inline void Type::set_has_tuple() {
  _oneof_case_[0] = kTuple;
}
inline void Type::clear_tuple() {
  if (_internal_has_tuple()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Detail_.tuple_;
    }
    clear_has_Detail();
  }
}
inline ::yune::Type_Tuple* Type::release_tuple() {
  // @@protoc_insertion_point(field_release:yune.Type.tuple)
  if (_internal_has_tuple()) {
    clear_has_Detail();
      ::yune::Type_Tuple* temp = Detail_.tuple_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Detail_.tuple_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::yune::Type_Tuple& Type::_internal_tuple() const {
  return _internal_has_tuple()
      ? *Detail_.tuple_
      : reinterpret_cast< ::yune::Type_Tuple&>(::yune::_Type_Tuple_default_instance_);
}
inline const ::yune::Type_Tuple& Type::tuple() const {
  // @@protoc_insertion_point(field_get:yune.Type.tuple)
  return _internal_tuple();
}
inline ::yune::Type_Tuple* Type::unsafe_arena_release_tuple() {
  // @@protoc_insertion_point(field_unsafe_arena_release:yune.Type.tuple)
  if (_internal_has_tuple()) {
    clear_has_Detail();
    ::yune::Type_Tuple* temp = Detail_.tuple_;
    Detail_.tuple_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_tuple(::yune::Type_Tuple* tuple) {
  clear_Detail();
  if (tuple) {
    set_has_tuple();
    Detail_.tuple_ = tuple;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:yune.Type.tuple)
}
inline ::yune::Type_Tuple* Type::_internal_mutable_tuple() {
  if (!_internal_has_tuple()) {
    clear_Detail();
    set_has_tuple();
    Detail_.tuple_ = CreateMaybeMessage< ::yune::Type_Tuple >(GetArenaForAllocation());
  }
  return Detail_.tuple_;
}
inline ::yune::Type_Tuple* Type::mutable_tuple() {
  ::yune::Type_Tuple* _msg = _internal_mutable_tuple();
  // @@protoc_insertion_point(field_mutable:yune.Type.tuple)
  return _msg;
}

// .yune.Type.List list = 4;
inline bool Type::_internal_has_list() const {
  return Detail_case() == kList;
}
inline bool Type::has_list() const {
  return _internal_has_list();
}
inline void Type::set_has_list() {
  _oneof_case_[0] = kList;
}
inline void Type::clear_list() {
  if (_internal_has_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Detail_.list_;
    }
    clear_has_Detail();
  }
}
inline ::yune::Type_List* Type::release_list() {
  // @@protoc_insertion_point(field_release:yune.Type.list)
  if (_internal_has_list()) {
    clear_has_Detail();
      ::yune::Type_List* temp = Detail_.list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Detail_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::yune::Type_List& Type::_internal_list() const {
  return _internal_has_list()
      ? *Detail_.list_
      : reinterpret_cast< ::yune::Type_List&>(::yune::_Type_List_default_instance_);
}
inline const ::yune::Type_List& Type::list() const {
  // @@protoc_insertion_point(field_get:yune.Type.list)
  return _internal_list();
}
inline ::yune::Type_List* Type::unsafe_arena_release_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:yune.Type.list)
  if (_internal_has_list()) {
    clear_has_Detail();
    ::yune::Type_List* temp = Detail_.list_;
    Detail_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_list(::yune::Type_List* list) {
  clear_Detail();
  if (list) {
    set_has_list();
    Detail_.list_ = list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:yune.Type.list)
}
inline ::yune::Type_List* Type::_internal_mutable_list() {
  if (!_internal_has_list()) {
    clear_Detail();
    set_has_list();
    Detail_.list_ = CreateMaybeMessage< ::yune::Type_List >(GetArenaForAllocation());
  }
  return Detail_.list_;
}
inline ::yune::Type_List* Type::mutable_list() {
  ::yune::Type_List* _msg = _internal_mutable_list();
  // @@protoc_insertion_point(field_mutable:yune.Type.list)
  return _msg;
}

// .yune.Type.Struct struct = 5;
inline bool Type::_internal_has_struct_() const {
  return Detail_case() == kStruct;
}
inline bool Type::has_struct_() const {
  return _internal_has_struct_();
}
inline void Type::set_has_struct_() {
  _oneof_case_[0] = kStruct;
}
inline void Type::clear_struct_() {
  if (_internal_has_struct_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Detail_.struct__;
    }
    clear_has_Detail();
  }
}
inline ::yune::Type_Struct* Type::release_struct_() {
  // @@protoc_insertion_point(field_release:yune.Type.struct)
  if (_internal_has_struct_()) {
    clear_has_Detail();
      ::yune::Type_Struct* temp = Detail_.struct__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Detail_.struct__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::yune::Type_Struct& Type::_internal_struct_() const {
  return _internal_has_struct_()
      ? *Detail_.struct__
      : reinterpret_cast< ::yune::Type_Struct&>(::yune::_Type_Struct_default_instance_);
}
inline const ::yune::Type_Struct& Type::struct_() const {
  // @@protoc_insertion_point(field_get:yune.Type.struct)
  return _internal_struct_();
}
inline ::yune::Type_Struct* Type::unsafe_arena_release_struct_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:yune.Type.struct)
  if (_internal_has_struct_()) {
    clear_has_Detail();
    ::yune::Type_Struct* temp = Detail_.struct__;
    Detail_.struct__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_struct_(::yune::Type_Struct* struct_) {
  clear_Detail();
  if (struct_) {
    set_has_struct_();
    Detail_.struct__ = struct_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:yune.Type.struct)
}
inline ::yune::Type_Struct* Type::_internal_mutable_struct_() {
  if (!_internal_has_struct_()) {
    clear_Detail();
    set_has_struct_();
    Detail_.struct__ = CreateMaybeMessage< ::yune::Type_Struct >(GetArenaForAllocation());
  }
  return Detail_.struct__;
}
inline ::yune::Type_Struct* Type::mutable_struct_() {
  ::yune::Type_Struct* _msg = _internal_mutable_struct_();
  // @@protoc_insertion_point(field_mutable:yune.Type.struct)
  return _msg;
}

inline bool Type::has_Detail() const {
  return Detail_case() != DETAIL_NOT_SET;
}
inline void Type::clear_has_Detail() {
  _oneof_case_[0] = DETAIL_NOT_SET;
}
inline Type::DetailCase Type::Detail_case() const {
  return Type::DetailCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Messages

// repeated .google.protobuf.Any messages = 1;
inline int Messages::_internal_messages_size() const {
  return messages_.size();
}
inline int Messages::messages_size() const {
  return _internal_messages_size();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Messages::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:yune.Messages.messages)
  return messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
Messages::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:yune.Messages.messages)
  return &messages_;
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Messages::_internal_messages(int index) const {
  return messages_.Get(index);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Messages::messages(int index) const {
  // @@protoc_insertion_point(field_get:yune.Messages.messages)
  return _internal_messages(index);
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Messages::_internal_add_messages() {
  return messages_.Add();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Messages::add_messages() {
  ::PROTOBUF_NAMESPACE_ID::Any* _add = _internal_add_messages();
  // @@protoc_insertion_point(field_add:yune.Messages.messages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
Messages::messages() const {
  // @@protoc_insertion_point(field_list:yune.Messages.messages)
  return messages_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace yune

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::yune::Type_Kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::yune::Type_Kind>() {
  return ::yune::Type_Kind_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proto_2ftype_2eproto
