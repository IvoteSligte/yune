// Code generated by capnpc-go. DO NOT EDIT.

package pb

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	strconv "strconv"
)

type Value capnp.Struct
type Value_Which uint16

const (
	Value_Which_nothing Value_Which = 0
	Value_Which_type    Value_Which = 1
)

func (w Value_Which) String() string {
	const s = "nothingtype"
	switch w {
	case Value_Which_nothing:
		return s[0:7]
	case Value_Which_type:
		return s[7:11]

	}
	return "Value_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Value_TypeID is the unique identifier for the type Value.
const Value_TypeID = 0xad454f2956d96537

func NewValue(s *capnp.Segment) (Value, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Value(st), err
}

func NewRootValue(s *capnp.Segment) (Value, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Value(st), err
}

func ReadRootValue(msg *capnp.Message) (Value, error) {
	root, err := msg.Root()
	return Value(root.Struct()), err
}

func (s Value) String() string {
	str, _ := text.Marshal(0xad454f2956d96537, capnp.Struct(s))
	return str
}

func (s Value) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Value) DecodeFromPtr(p capnp.Ptr) Value {
	return Value(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Value) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Value) Which() Value_Which {
	return Value_Which(capnp.Struct(s).Uint16(0))
}
func (s Value) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Value) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Value) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Value) SetNothing() {
	capnp.Struct(s).SetUint16(0, 0)

}

func (s Value) Type() (Value_Type, error) {
	if capnp.Struct(s).Uint16(0) != 1 {
		panic("Which() != type")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return Value_Type(p.Struct()), err
}

func (s Value) HasType() bool {
	if capnp.Struct(s).Uint16(0) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Value) SetType(v Value_Type) error {
	capnp.Struct(s).SetUint16(0, 1)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewType sets the type field to a newly
// allocated Value_Type struct, preferring placement in s's segment.
func (s Value) NewType() (Value_Type, error) {
	capnp.Struct(s).SetUint16(0, 1)
	ss, err := NewValue_Type(capnp.Struct(s).Segment())
	if err != nil {
		return Value_Type{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Value_List is a list of Value.
type Value_List = capnp.StructList[Value]

// NewValue creates a new list of Value.
func NewValue_List(s *capnp.Segment, sz int32) (Value_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[Value](l), err
}

// Value_Future is a wrapper for a Value promised by a client call.
type Value_Future struct{ *capnp.Future }

func (f Value_Future) Struct() (Value, error) {
	p, err := f.Future.Ptr()
	return Value(p.Struct()), err
}
func (p Value_Future) Type() Value_Type_Future {
	return Value_Type_Future{Future: p.Future.Field(0, nil)}
}

type Value_Type capnp.Struct
type Value_Type_fn Value_Type
type Value_Type_struc Value_Type
type Value_Type_Which uint16

const (
	Value_Type_Which_type    Value_Type_Which = 0
	Value_Type_Which_int     Value_Type_Which = 1
	Value_Type_Which_float   Value_Type_Which = 2
	Value_Type_Which_bool    Value_Type_Which = 3
	Value_Type_Which_string_ Value_Type_Which = 4
	Value_Type_Which_nil     Value_Type_Which = 5
	Value_Type_Which_fn      Value_Type_Which = 6
	Value_Type_Which_tuple   Value_Type_Which = 7
	Value_Type_Which_list    Value_Type_Which = 8
	Value_Type_Which_struc   Value_Type_Which = 9
)

func (w Value_Type_Which) String() string {
	const s = "typeintfloatboolstring_nilfntupleliststruc"
	switch w {
	case Value_Type_Which_type:
		return s[0:4]
	case Value_Type_Which_int:
		return s[4:7]
	case Value_Type_Which_float:
		return s[7:12]
	case Value_Type_Which_bool:
		return s[12:16]
	case Value_Type_Which_string_:
		return s[16:23]
	case Value_Type_Which_nil:
		return s[23:26]
	case Value_Type_Which_fn:
		return s[26:28]
	case Value_Type_Which_tuple:
		return s[28:33]
	case Value_Type_Which_list:
		return s[33:37]
	case Value_Type_Which_struc:
		return s[37:42]

	}
	return "Value_Type_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Value_Type_TypeID is the unique identifier for the type Value_Type.
const Value_Type_TypeID = 0xe6a9443313a9ccd0

func NewValue_Type(s *capnp.Segment) (Value_Type, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Value_Type(st), err
}

func NewRootValue_Type(s *capnp.Segment) (Value_Type, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Value_Type(st), err
}

func ReadRootValue_Type(msg *capnp.Message) (Value_Type, error) {
	root, err := msg.Root()
	return Value_Type(root.Struct()), err
}

func (s Value_Type) String() string {
	str, _ := text.Marshal(0xe6a9443313a9ccd0, capnp.Struct(s))
	return str
}

func (s Value_Type) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Value_Type) DecodeFromPtr(p capnp.Ptr) Value_Type {
	return Value_Type(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Value_Type) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Value_Type) Which() Value_Type_Which {
	return Value_Type_Which(capnp.Struct(s).Uint16(0))
}
func (s Value_Type) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Value_Type) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Value_Type) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Value_Type) SetType() {
	capnp.Struct(s).SetUint16(0, 0)

}

func (s Value_Type) SetInt() {
	capnp.Struct(s).SetUint16(0, 1)

}

func (s Value_Type) SetFloat() {
	capnp.Struct(s).SetUint16(0, 2)

}

func (s Value_Type) SetBool() {
	capnp.Struct(s).SetUint16(0, 3)

}

func (s Value_Type) SetString_() {
	capnp.Struct(s).SetUint16(0, 4)

}

func (s Value_Type) SetNil() {
	capnp.Struct(s).SetUint16(0, 5)

}

func (s Value_Type) Fn() Value_Type_fn { return Value_Type_fn(s) }

func (s Value_Type) SetFn() {
	capnp.Struct(s).SetUint16(0, 6)
}

func (s Value_Type_fn) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Value_Type_fn) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Value_Type_fn) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Value_Type_fn) Argument() (Value_Type, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Value_Type(p.Struct()), err
}

func (s Value_Type_fn) HasArgument() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Value_Type_fn) SetArgument(v Value_Type) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewArgument sets the argument field to a newly
// allocated Value_Type struct, preferring placement in s's segment.
func (s Value_Type_fn) NewArgument() (Value_Type, error) {
	ss, err := NewValue_Type(capnp.Struct(s).Segment())
	if err != nil {
		return Value_Type{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Value_Type_fn) Return() (Value_Type, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Value_Type(p.Struct()), err
}

func (s Value_Type_fn) HasReturn() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Value_Type_fn) SetReturn(v Value_Type) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewReturn sets the return field to a newly
// allocated Value_Type struct, preferring placement in s's segment.
func (s Value_Type_fn) NewReturn() (Value_Type, error) {
	ss, err := NewValue_Type(capnp.Struct(s).Segment())
	if err != nil {
		return Value_Type{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Value_Type) Tuple() (Value_Type_List, error) {
	if capnp.Struct(s).Uint16(0) != 7 {
		panic("Which() != tuple")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return Value_Type_List(p.List()), err
}

func (s Value_Type) HasTuple() bool {
	if capnp.Struct(s).Uint16(0) != 7 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Value_Type) SetTuple(v Value_Type_List) error {
	capnp.Struct(s).SetUint16(0, 7)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewTuple sets the tuple field to a newly
// allocated Value_Type_List, preferring placement in s's segment.
func (s Value_Type) NewTuple(n int32) (Value_Type_List, error) {
	capnp.Struct(s).SetUint16(0, 7)
	l, err := NewValue_Type_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Value_Type_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Value_Type) List() (Value_Type, error) {
	if capnp.Struct(s).Uint16(0) != 8 {
		panic("Which() != list")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return Value_Type(p.Struct()), err
}

func (s Value_Type) HasList() bool {
	if capnp.Struct(s).Uint16(0) != 8 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Value_Type) SetList(v Value_Type) error {
	capnp.Struct(s).SetUint16(0, 8)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewList sets the list field to a newly
// allocated Value_Type struct, preferring placement in s's segment.
func (s Value_Type) NewList() (Value_Type, error) {
	capnp.Struct(s).SetUint16(0, 8)
	ss, err := NewValue_Type(capnp.Struct(s).Segment())
	if err != nil {
		return Value_Type{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Value_Type) Struc() Value_Type_struc { return Value_Type_struc(s) }

func (s Value_Type) SetStruc() {
	capnp.Struct(s).SetUint16(0, 9)
}

func (s Value_Type_struc) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Value_Type_struc) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Value_Type_struc) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Value_Type_struc) Name() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Value_Type_struc) HasName() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Value_Type_struc) NameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Value_Type_struc) SetName(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// Value_Type_List is a list of Value_Type.
type Value_Type_List = capnp.StructList[Value_Type]

// NewValue_Type creates a new list of Value_Type.
func NewValue_Type_List(s *capnp.Segment, sz int32) (Value_Type_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return capnp.StructList[Value_Type](l), err
}

// Value_Type_Future is a wrapper for a Value_Type promised by a client call.
type Value_Type_Future struct{ *capnp.Future }

func (f Value_Type_Future) Struct() (Value_Type, error) {
	p, err := f.Future.Ptr()
	return Value_Type(p.Struct()), err
}
func (p Value_Type_Future) Fn() Value_Type_fn_Future { return Value_Type_fn_Future{p.Future} }

// Value_Type_fn_Future is a wrapper for a Value_Type_fn promised by a client call.
type Value_Type_fn_Future struct{ *capnp.Future }

func (f Value_Type_fn_Future) Struct() (Value_Type_fn, error) {
	p, err := f.Future.Ptr()
	return Value_Type_fn(p.Struct()), err
}
func (p Value_Type_fn_Future) Argument() Value_Type_Future {
	return Value_Type_Future{Future: p.Future.Field(0, nil)}
}
func (p Value_Type_fn_Future) Return() Value_Type_Future {
	return Value_Type_Future{Future: p.Future.Field(1, nil)}
}
func (p Value_Type_Future) List() Value_Type_Future {
	return Value_Type_Future{Future: p.Future.Field(0, nil)}
}
func (p Value_Type_Future) Struc() Value_Type_struc_Future { return Value_Type_struc_Future{p.Future} }

// Value_Type_struc_Future is a wrapper for a Value_Type_struc promised by a client call.
type Value_Type_struc_Future struct{ *capnp.Future }

func (f Value_Type_struc_Future) Struct() (Value_Type_struc, error) {
	p, err := f.Future.Ptr()
	return Value_Type_struc(p.Struct()), err
}

const schema_eaa1f06c3c8d5689 = "x\xda\x94\x92?k\x14A\x00\xc5\xdf\x9b\xd9\xec^\xc2" +
	"]\xee\x8e\xd9`\x0cJ\x12I\x91\x1c&\xe4\x8f\x10\x09" +
	"JT\xbcB!\x98\xe1$\xad\xaca\x93\x1c\xec\xed\x1d" +
	"w\xbbh\x0aQ\xb0\x12\xf4\x0bXi\x99\xc2/ac" +
	"c\xa1e\x84\x086\x16Vb\xe1\x7f\x1d\x99\x95\\N" +
	"cc\xbb\xbf\xe5\xf7\xde\xcc\xbc\xd9\x15\x9es\xe6\x0a\xcf" +
	"\x04\x84\x1e\xebs\x8d\x18\xdb\x1b\xb96t\xff\x0e\xf40" +
	"i^<\xdfQ\x0b\x17w\xdebHx\x04\xd4%~" +
	"\x00\xd5\x0a\x97A\xb3\x18\xee\xaeM]\xa9>\x81.\x90" +
	"\xe6\xde\xda\x833\xd1\xfb\xc7\xefP\xa5'\x00\xd5\xe0C" +
	"\x95\xf2\x08\xa0n\xf1\x06h\xde\xbc\x9c\xbdy\xf7\xd1\xde" +
	"\xeb\x7f{w\xf9\x0aT{\xd9\x9f]\xa6\x15{R\xaa" +
	"\xc2\x1b\x00\xd4Y\xf1TU\x85\x07,\x9c\x17\x8b\x02\xd3" +
	"\xa6\xb3\xbe\x156\x82\x99u\x11\xb4\xe2\xd6\xd2Z\x10\xa5" +
	"\xe1\xcc\xd5\xedV83\xdaI\xda\xe9\xbav\xa4\x03\xf8" +
	"\x1c\x00\xca\x85\x0a\xa0s\x92\xda\x17,\xc6A#d\x1e" +
	"\x82y\xb0+\xe1\xbeD\xa6\xa1vz\x8b\x96Y)Z" +
	"\xad\xceI'o\x8cC\xa0<u\x01\xd0\x13\x92zV" +
	"\xb0\xc0\x9f\xc6\xa7\xfd:mS&%\xf5)\xc1\xdbq" +
	"3\xd9\xaa\xc7\x9bp\x8b\xc9v+d\xe9@\x08\xb2\xd4" +
	"\x93|\xa8\xbe\xdc\x88m\x96\xed\xee\xda\xac\xcb\x07\xd62" +
	"\xe9\xd3\x03\xcasK\x80>)\xa9O\x0b\x9a\xa0\xbd\x99" +
	"6\xc28\x01p8g\xb9\x1d&i;\xfe\x8f\x02X" +
	"%\xf5d\xf7\xb0\xaa\x9f\x15\xa0\xe6P\xb2Vb\xcfy" +
	"U\x81'\x80Z\xce\x02\xdf\x02\xf1\xc3\xf8\xb4\x13(s" +
	"\x1e\xa8\xe5-\x18\xb6@~7>%\xa0\x862U\xc9" +
	"\x82c\x168\xdf\x8cO\x07PG\xb9\x04\xd4|\x0b\xc6" +
	",\xe8\xfbj|\xf6\x01\xeax\x961l\xc1\x84\x05\xee" +
	"\x17\xc3\x9eM\xa9q\x8e@\x14\xbc\xcf\xc6g.\xeb:" +
	"\xbf\xdf5\xf3\xe4>\x19\x9f\xfd\x99\xa7\xf2\x87\xa7\xff\xa3" +
	"\xf5t7\xaf\xc69\x0f\x91=\x15\\\xaf\x1e'pG" +
	"7\xa2f\x90\xc0-^o6#\xb8\xcb\x9d\xa4\x9d\xbd" +
	"\xa7\x17\xd7#\xb8r#\x1eM\xd2V\x14r\x10\\\x95" +
	"\xfc\xeb~\x07\xc1bT\xef$\x87\xaf\xfd\xf78\x7f\x05" +
	"\x00\x00\xff\xff\x8b4\xda\x88"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_eaa1f06c3c8d5689,
		Nodes: []uint64{
			0x808c155f1add2002,
			0xad454f2956d96537,
			0xdedda0837830d1e1,
			0xe6a9443313a9ccd0,
		},
		Compressed: true,
	})
}
