// Code generated by capnpc-go. DO NOT EDIT.

package pb

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	strconv "strconv"
)

type Value capnp.Struct
type Value_Which uint16

const (
	Value_Which_empty Value_Which = 0
	Value_Which_type  Value_Which = 1
)

func (w Value_Which) String() string {
	const s = "emptytype"
	switch w {
	case Value_Which_empty:
		return s[0:5]
	case Value_Which_type:
		return s[5:9]

	}
	return "Value_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Value_TypeID is the unique identifier for the type Value.
const Value_TypeID = 0xad454f2956d96537

func NewValue(s *capnp.Segment) (Value, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Value(st), err
}

func NewRootValue(s *capnp.Segment) (Value, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Value(st), err
}

func ReadRootValue(msg *capnp.Message) (Value, error) {
	root, err := msg.Root()
	return Value(root.Struct()), err
}

func (s Value) String() string {
	str, _ := text.Marshal(0xad454f2956d96537, capnp.Struct(s))
	return str
}

func (s Value) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Value) DecodeFromPtr(p capnp.Ptr) Value {
	return Value(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Value) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Value) Which() Value_Which {
	return Value_Which(capnp.Struct(s).Uint16(0))
}
func (s Value) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Value) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Value) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Value) SetEmpty() {
	capnp.Struct(s).SetUint16(0, 0)

}

func (s Value) Type() (Value_Type, error) {
	if capnp.Struct(s).Uint16(0) != 1 {
		panic("Which() != type")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return Value_Type(p.Struct()), err
}

func (s Value) HasType() bool {
	if capnp.Struct(s).Uint16(0) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Value) SetType(v Value_Type) error {
	capnp.Struct(s).SetUint16(0, 1)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewType sets the type field to a newly
// allocated Value_Type struct, preferring placement in s's segment.
func (s Value) NewType() (Value_Type, error) {
	capnp.Struct(s).SetUint16(0, 1)
	ss, err := NewValue_Type(capnp.Struct(s).Segment())
	if err != nil {
		return Value_Type{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Value_List is a list of Value.
type Value_List = capnp.StructList[Value]

// NewValue creates a new list of Value.
func NewValue_List(s *capnp.Segment, sz int32) (Value_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[Value](l), err
}

// Value_Future is a wrapper for a Value promised by a client call.
type Value_Future struct{ *capnp.Future }

func (f Value_Future) Struct() (Value, error) {
	p, err := f.Future.Ptr()
	return Value(p.Struct()), err
}
func (p Value_Future) Type() Value_Type_Future {
	return Value_Type_Future{Future: p.Future.Field(0, nil)}
}

type Value_Type capnp.Struct
type Value_Type_fn Value_Type
type Value_Type_struc Value_Type
type Value_Type_Which uint16

const (
	Value_Type_Which_type    Value_Type_Which = 0
	Value_Type_Which_int     Value_Type_Which = 1
	Value_Type_Which_float   Value_Type_Which = 2
	Value_Type_Which_bool    Value_Type_Which = 3
	Value_Type_Which_string_ Value_Type_Which = 4
	Value_Type_Which_nil     Value_Type_Which = 5
	Value_Type_Which_fn      Value_Type_Which = 6
	Value_Type_Which_tuple   Value_Type_Which = 7
	Value_Type_Which_list    Value_Type_Which = 8
	Value_Type_Which_struc   Value_Type_Which = 9
)

func (w Value_Type_Which) String() string {
	const s = "typeintfloatboolstring_nilfntupleliststruc"
	switch w {
	case Value_Type_Which_type:
		return s[0:4]
	case Value_Type_Which_int:
		return s[4:7]
	case Value_Type_Which_float:
		return s[7:12]
	case Value_Type_Which_bool:
		return s[12:16]
	case Value_Type_Which_string_:
		return s[16:23]
	case Value_Type_Which_nil:
		return s[23:26]
	case Value_Type_Which_fn:
		return s[26:28]
	case Value_Type_Which_tuple:
		return s[28:33]
	case Value_Type_Which_list:
		return s[33:37]
	case Value_Type_Which_struc:
		return s[37:42]

	}
	return "Value_Type_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Value_Type_TypeID is the unique identifier for the type Value_Type.
const Value_Type_TypeID = 0xe6a9443313a9ccd0

func NewValue_Type(s *capnp.Segment) (Value_Type, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Value_Type(st), err
}

func NewRootValue_Type(s *capnp.Segment) (Value_Type, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Value_Type(st), err
}

func ReadRootValue_Type(msg *capnp.Message) (Value_Type, error) {
	root, err := msg.Root()
	return Value_Type(root.Struct()), err
}

func (s Value_Type) String() string {
	str, _ := text.Marshal(0xe6a9443313a9ccd0, capnp.Struct(s))
	return str
}

func (s Value_Type) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Value_Type) DecodeFromPtr(p capnp.Ptr) Value_Type {
	return Value_Type(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Value_Type) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Value_Type) Which() Value_Type_Which {
	return Value_Type_Which(capnp.Struct(s).Uint16(0))
}
func (s Value_Type) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Value_Type) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Value_Type) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Value_Type) SetType() {
	capnp.Struct(s).SetUint16(0, 0)

}

func (s Value_Type) SetInt() {
	capnp.Struct(s).SetUint16(0, 1)

}

func (s Value_Type) SetFloat() {
	capnp.Struct(s).SetUint16(0, 2)

}

func (s Value_Type) SetBool() {
	capnp.Struct(s).SetUint16(0, 3)

}

func (s Value_Type) SetString_() {
	capnp.Struct(s).SetUint16(0, 4)

}

func (s Value_Type) SetNil() {
	capnp.Struct(s).SetUint16(0, 5)

}

func (s Value_Type) Fn() Value_Type_fn { return Value_Type_fn(s) }

func (s Value_Type) SetFn() {
	capnp.Struct(s).SetUint16(0, 6)
}

func (s Value_Type_fn) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Value_Type_fn) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Value_Type_fn) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Value_Type_fn) Argument() (Value_Type, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Value_Type(p.Struct()), err
}

func (s Value_Type_fn) HasArgument() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Value_Type_fn) SetArgument(v Value_Type) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewArgument sets the argument field to a newly
// allocated Value_Type struct, preferring placement in s's segment.
func (s Value_Type_fn) NewArgument() (Value_Type, error) {
	ss, err := NewValue_Type(capnp.Struct(s).Segment())
	if err != nil {
		return Value_Type{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Value_Type_fn) Return() (Value_Type, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Value_Type(p.Struct()), err
}

func (s Value_Type_fn) HasReturn() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Value_Type_fn) SetReturn(v Value_Type) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewReturn sets the return field to a newly
// allocated Value_Type struct, preferring placement in s's segment.
func (s Value_Type_fn) NewReturn() (Value_Type, error) {
	ss, err := NewValue_Type(capnp.Struct(s).Segment())
	if err != nil {
		return Value_Type{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Value_Type) Tuple() (Value_Type_List, error) {
	if capnp.Struct(s).Uint16(0) != 7 {
		panic("Which() != tuple")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return Value_Type_List(p.List()), err
}

func (s Value_Type) HasTuple() bool {
	if capnp.Struct(s).Uint16(0) != 7 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Value_Type) SetTuple(v Value_Type_List) error {
	capnp.Struct(s).SetUint16(0, 7)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewTuple sets the tuple field to a newly
// allocated Value_Type_List, preferring placement in s's segment.
func (s Value_Type) NewTuple(n int32) (Value_Type_List, error) {
	capnp.Struct(s).SetUint16(0, 7)
	l, err := NewValue_Type_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Value_Type_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Value_Type) List() (Value_Type, error) {
	if capnp.Struct(s).Uint16(0) != 8 {
		panic("Which() != list")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return Value_Type(p.Struct()), err
}

func (s Value_Type) HasList() bool {
	if capnp.Struct(s).Uint16(0) != 8 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Value_Type) SetList(v Value_Type) error {
	capnp.Struct(s).SetUint16(0, 8)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewList sets the list field to a newly
// allocated Value_Type struct, preferring placement in s's segment.
func (s Value_Type) NewList() (Value_Type, error) {
	capnp.Struct(s).SetUint16(0, 8)
	ss, err := NewValue_Type(capnp.Struct(s).Segment())
	if err != nil {
		return Value_Type{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Value_Type) Struc() Value_Type_struc { return Value_Type_struc(s) }

func (s Value_Type) SetStruc() {
	capnp.Struct(s).SetUint16(0, 9)
}

func (s Value_Type_struc) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Value_Type_struc) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Value_Type_struc) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Value_Type_struc) Name() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Value_Type_struc) HasName() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Value_Type_struc) NameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Value_Type_struc) SetName(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// Value_Type_List is a list of Value_Type.
type Value_Type_List = capnp.StructList[Value_Type]

// NewValue_Type creates a new list of Value_Type.
func NewValue_Type_List(s *capnp.Segment, sz int32) (Value_Type_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return capnp.StructList[Value_Type](l), err
}

// Value_Type_Future is a wrapper for a Value_Type promised by a client call.
type Value_Type_Future struct{ *capnp.Future }

func (f Value_Type_Future) Struct() (Value_Type, error) {
	p, err := f.Future.Ptr()
	return Value_Type(p.Struct()), err
}
func (p Value_Type_Future) Fn() Value_Type_fn_Future { return Value_Type_fn_Future{p.Future} }

// Value_Type_fn_Future is a wrapper for a Value_Type_fn promised by a client call.
type Value_Type_fn_Future struct{ *capnp.Future }

func (f Value_Type_fn_Future) Struct() (Value_Type_fn, error) {
	p, err := f.Future.Ptr()
	return Value_Type_fn(p.Struct()), err
}
func (p Value_Type_fn_Future) Argument() Value_Type_Future {
	return Value_Type_Future{Future: p.Future.Field(0, nil)}
}
func (p Value_Type_fn_Future) Return() Value_Type_Future {
	return Value_Type_Future{Future: p.Future.Field(1, nil)}
}
func (p Value_Type_Future) List() Value_Type_Future {
	return Value_Type_Future{Future: p.Future.Field(0, nil)}
}
func (p Value_Type_Future) Struc() Value_Type_struc_Future { return Value_Type_struc_Future{p.Future} }

// Value_Type_struc_Future is a wrapper for a Value_Type_struc promised by a client call.
type Value_Type_struc_Future struct{ *capnp.Future }

func (f Value_Type_struc_Future) Struct() (Value_Type_struc, error) {
	p, err := f.Future.Ptr()
	return Value_Type_struc(p.Struct()), err
}

const schema_eaa1f06c3c8d5689 = "x\xda\x94\x92\xcfk\x13O\x00\xc5\xdf\x9b\xd9\xee\xa6%" +
	"i\x12f\xcb\xb7\xdf\xa2\xa4\x95\x1e\xda`K\x9b\x0a\x95" +
	"\xa2T\xc1\x1c\x14\x8a\x1d\"\xbdJ,\xdb\x1a\xd8l\x97" +
	"d\x17\xedA\x10<\x09\xfa\x0fx\xd2c\x0f\xfe\x13^" +
	"\xbcx\xd0c\x85\x0a^<x\x12\x0f\xfe\xd6\x91Yi" +
	"\x1a\x8d\x17\xaf\xfbY>\xef\xcd\xcc[X\xe39g\xb1" +
	"\xf0T@\xe8\xc9!\xd7\x88\xc9\x83\x89\xabc\xf7nC" +
	"\x8f\x93\xe6\xf9\xb3=\xb5ta\xef\x0d\xc6\x84G@]" +
	"\xe4{P\xadq\x154\xcb\xc1\xfe\xc6\xec\xe5\xfac\xe8" +
	"\x02i\xeen\xdc?\x13\xbe{\xf4\x16uz\x02Pm" +
	">P)\xff\x03\xd4-\xde\x00\xcd\xeb\x17\x0b7\xef<" +
	"<x\xf5w\xef>_\x82\xea \xfb\xb3\xc7\xb4b_" +
	"J]x#\x80:+\x9e\xa8\xba\xf0\x80\xa5\xf3bY" +
	"`\xcet7\xaf\x07\xed\xe6\xfc\xa6h\xc6Q\xbc\xb2\xd1" +
	"\x0c\xd3`\xfe\xcan\x1c\xccW\xbaI'\xdd\xd4\x8et" +
	"\x00\x9f#@\xb9P\x05tNR\xfb\x82\xc5\xa8\xd9\x0e" +
	"\x98\x87`\x1e\xecIx(\x91i\xa0\x9d\xfe\xa2eV" +
	"\x8bV\xabs\xd2\xc9\x1b\xe3\x10(\xcf\xd6\x00=-\xa9" +
	"\x17\x04\x0b\xfca|\xda\xafs6eFR\x9f\x12\xac" +
	"\x04\xed8\xd9\x85[Lv\xe3\x80\xa5#\x1d\xc8R_" +
	"\xee@y\xb9\x15\xd9$\xdb\xdc\xb5I\x97\x8e\x9ce\xd2" +
	"\xa7\x07\x94\x17W\x00}RR\x9f\x164\xcd\xcev\xda" +
	"\x0e\xa2\x04\xc0`\xcej'H\xd2N\xf4\x0f\x05\xb0N" +
	"\xea\x99\xdeQ\xd50\xab@\xc3\xa1d\xa3\xc4\xbe\xd3\xaa" +
	"\x02O\x00\x8d\x9c\x05\xbe\x05\xe2\xbb\xf1i\x07Pf\x0d" +
	"h\xe4-\x18\xb7@~3>%\xa0\xc62U\xc9\x82" +
	"c\x168_\x8dO\x07P\xffs\x05h\xf8\x16LZ" +
	"0\xf4\xc5\xf8\x1c\x02\xd4\xf1,c\xdc\x82i\x0b\xdc\xcf" +
	"\x86}\x8bRS\x9c\x80(x\x9f\x8c\xcf\\\xd6\xb5v" +
	"\xd85\xf3\xe4>\x1a\x9f\xc3\x99\xa7\xfa\x9bg\xf8\x83\xf5" +
	"\xf4\x16\xaf\xa6X\x83\xc8\x9e\x0a\xae\xd7\x8a\x12\xb8\x95\xad" +
	"p\xa7\x99\xc0-^\xdb\xd9\x09\xe1\xaev\x93N+\xda" +
	"\x86\xebE\xad\x10\xae\xdc\x8a*I\x1a\x87\x01G\xc1u" +
	"\xc9?\xeew\x14,\x86\xadn2x\xed\xbf\xa6\xf93" +
	"\x00\x00\xff\xff8\xdd\xd9P"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_eaa1f06c3c8d5689,
		Nodes: []uint64{
			0x808c155f1add2002,
			0xad454f2956d96537,
			0xdedda0837830d1e1,
			0xe6a9443313a9ccd0,
		},
		Compressed: true,
	})
}
